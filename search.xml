<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端基本知识]]></title>
    <url>%2F2019%2F12%2F13%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[虽然有些东西每天用到，但是并不意味着真的记住了，经常的就是知道有那么个东西存在，然后去百度，谷歌。有人说，写程序不就是 CV大法么？我觉得如果能熟记于心的话，对自己也是一种提升。 CSS盒模型盒模型: 由 content , padding ,border , margin 组成。但是 mraing 只是盒子占据的位置，而不组成盒子的大小。 盒模型有两种方式： 标准盒模型: 由 content 组成。 IE盒模型: 由 content + padding + border 组成。 CSS3的新特性 选择器: element1~element2: 选择前面有element1元素的每个element2元素。 [attribute^=value]: 选择某元素attribute属性是以value开头的。 [attribute$=value]: 选择某元素attribute属性是以value结尾的。 [attribute*=value]: 选择某元素attribute属性包含value字符串的。 E:first-of-type: 选择属于其父元素的首个E元素的每个E元素。 E:last-of-type: 选择属于其父元素的最后E元素的每个E元素。 E:only-of-type: 选择属于其父元素唯一的E元素的每个E元素。 E:only-child: 选择属于其父元素的唯一子元素的每个E元素。 E:nth-child(n): 选择属于其父元素的第n个子元素的每个E元素。 E:nth-last-child(n): 选择属于其父元素的倒数第n个子元素的每个E元素。 E:nth-of-type(n): 选择属于其父元素第n个E元素的每个E元素。 E:nth-last-of-type(n): 选择属于其父元素倒数第n个E元素的每个E元素。 E:last-child: 选择属于其父元素最后一个子元素每个E元素。 :root: 选择文档的根元素。 E:empty: 选择没有子元素的每个E元素（包括文本节点)。 E:target: 选择当前活动的E元素。 E:enabled: 选择每个启用的E元素。 E:disabled: 选择每个禁用的E元素。 E:checked: 选择每个被选中的E元素。 E:not(selector): 选择非selector元素的每个元素。 E::selection: 选择被用户选取的元素部分。 动画 Transition: 动画过渡效果。 Transform:应用各种2D和3D转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。 Animation: 制作动画的功能。 文字效果 word-wrap: 是否换行 text-overflow: 超过边界时是否显示 text-shadow: 文字投影 text-decoration: 文字渲染 text-fill-color: 设置文字内部填充颜色 text-stroke-color: 设置文字边界填充颜色 text-stroke-width: 设置文字边界宽度 渐变 linear-gradient: 线性渐变 radial-gradient: 径向渐变 尺寸 resize: 是否可由用户调整元素尺寸 // 如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll。 盒模型 // 标准盒模型 box-sizing:content-box; // IE盒模型 box-sizing: border-box; CSS选择器及其优先级从上之下依次是： !important 优先级爆表 内联样式 style=”” id 选择器 #id 类选择器 .class / 属性选择器 .class[href=””] / 伪类选择器 ::after 元素选择器 div / 关系选择器 div+span / 伪元素选择器 通配符选择器 * BFC BFC (block formatting context): 格式化上下文，是盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 应用 防止 margin 重叠 清楚内部浮动 自适应多栏布局 防止字体环绕 触发条件 根元素 float的值不为 none overflow 的值不为 visible display 的值为 inline-block,table-cell, table-caption position 的值为 absolute, fixed 特性 内部的 Box 是紧邻的垂直摆放的 垂直方向上的距离由 margin 决定 BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动元素也参与计算 BFC 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素 水平居中// 行内元素 text-align: center; // 块级元素 margin: 0 auto; // flex布局 display: flex; justify-content: center; // 绝对定位定宽 position: absolute; width: 宽度; left:50%; margin-left: -0.5*宽度 // 绝对定位不定宽 position: absolute; left: 50%; transform: translate(-50%, 0); // left,right: 0 position: absolute; width: 宽度; left: 0; right: 0; margin: 0 auto; 垂直居中// 行内元素 height: 高度; line-height: 高度; // table .parent { display: table; } .son { display: table-cell; vertical-align: middle; } // flex display: flex; align-items: center; // 绝对定位 position: absolute; top: 50%; height: 高度; margin-top: -0.5高度; // 绝对定位不定高 position: absolute; top: 50%; transform: translate( 0, -50%); // top,bottom: 0 position: absolute; top: 0; bottom: 0; margin: auto 0;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 多语言切换]]></title>
    <url>%2F2019%2F12%2F11%2FVue-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Vue I18n 是 Vue.js 的国际化插件。它可以轻松地将一些本地化功能集成到你的 Vue.js 应用程序中。 安装我使用的是 npm 安装 npm install vue-i18n 然后在 main.js 中引入 vue-i18n // main.js import Vue from &#39;vue&#39; import VueI18n from &#39;vue-i18n&#39; Vue.use(VueI18n) 新建语言文件新建一个文件夹 l18n（文件夹名字随意），用于存放语言文件。在文件夹中新建 zh.js 和 ja.js 文件。分别用于存放中文和日文的语言文件。 // zh.js module.exports = { message: { title: &#39;你好! 世界&#39;, hello: &#39;{msg}的世界&#39;, helloT: &#39;你好!{0}&#39;, helloH: &#39;你好! &lt;br&gt; 世界&#39; }, placeholder: { enter: &#39;你想对世界说的话&#39; }, meal: { breakfast: &#39;早餐&#39;, lunch: &#39;中餐&#39;, dinner: &#39;晚餐&#39;, supper: &#39;夜宵&#39; } } // ja.js // 注意：一定是 exports，不是 export，否则会报错，报错信息是下列的中的内容不是 string module.exports = { message: { title: &#39;ハロー! 世界&#39;, hello: &#39;{msg}の世界&#39;, helloT: &#39;ハロー!{0}&#39;, helloH: &#39;ハロー! &lt;br&gt; 世界&#39; }, placeholder: { enter: &#39;世界に言いたいことを入力してください&#39; }, meal: { breakfast: &#39;朝食&#39;, lunch: &#39;ランチ&#39;, dinner: &#39;ディナー&#39;, supper: &#39;ナイトナイト&#39; } } 引用语言文件设置完语言文件后，在 mian.js 中进行引用 const i18n = new VueI18n({ locale: &#39;zh&#39;, // 默认语言标识 messages: { &#39;ja&#39;: require(&#39;@/l18n/lang/ja&#39;), // 语言文件目录地址 &#39;zh&#39;: require(&#39;@/l18n/lang/zh&#39;) // 语言文件目录地址 } }) // 在 new 中新增i18n new Vue({ el: &#39;#app&#39;, ... i18n }) 使用在语言文件中的变量都是$t(&#39;键名&#39;)，接下来就可以在组件中使用了。 直接使用 &lt;!--.vue--&gt; &lt;p&gt;{{ $t("message.title") }}&lt;/p&gt; &lt;!--经过编译后就会变成--&gt; &lt;p&gt;你好！世界&lt;/p&gt; 比如需要绑定某些属性 &lt;input type=&quot;text&quot; :placeholder=&quot;$t(&#39;message.title&#39;)&quot;&gt; &lt;!--经过编译后就会变成--&gt; &lt;input type=&quot;text&quot; placeholder=&quot;你好!世界&quot;&gt; 变量使用 我们可以看到 message.hello 的值里面有个花括号 {msg},这里便是传入变量的地方 &lt;p&gt;{{ $t("message.hello", { msg: '绪锋' }) }}&lt;/p&gt; &lt;!--经过编译后就会变成--&gt; &lt;p&gt;绪锋的世界&lt;/p&gt; 还有一些其他的属性和方法，可以自己去官网查看，这就算一个简单的入门吧。 更换语言选项 每个组件都包含一个引用为 $i18n 属性的 VueI18n 实例，该实例也可用于更改语言环境. 每个组件都包含有一个 $i18n.locale 的属性，我们只需要更改这个属性的值，就达到了更换语言选项的目的。 // template &lt;button @click=&quot;selectLang()&quot;&gt;中文/日文&lt;/button&gt; // script selectLang () { this.$i18n.locale = this.$i18n.locale === &#39;zh&#39; ? &#39;ja&#39; : &#39;zh&#39; } 至此，一个简单的国际化就算完成了。 项目源代码见 Github]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 本地存储]]></title>
    <url>%2F2019%2F12%2F10%2FVue-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[通过把数据存储在浏览器中，用户不必每次都向服务器请求获取同一个信息。在你离线时，使用本地存储的数据而不是向远端服务器上请求数据就显得非常有用。 做个小案例，输入数据，并保存至本地存储中，并实时更新列表，可以对列表进行删除。 思路 首先实现一个双向绑定。输入框与列表的绑定，可以新增，删除列表。 然后把列表的数据绑定到本地存储中。 列表的双向绑定因为主要是实现功能，所以就没有做任何样式了。 页面由两部分组成，一部分是输入框和新增按钮。另一部分是列表。 &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; placeholder=&quot;等待输入&quot;&gt; &lt;button @click=&quot;addClick()&quot;&gt;新增&lt;/button&gt; &lt;/div&gt; &lt;!--列表--&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in msgList&quot; :key=&quot;index&quot;&gt; {{item}} &lt;button @click=&quot;clearClick(index)&quot;&gt;remvoe&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; 下面是关于列表的新增和删除，这部分非常简单，可以先自己实现一下。 删除的方法就是传入当前的列表的下标，进行删除。 data () { return { // 双向绑定 msg msg: &#39;&#39;, // 列表循环msgList msgList: [] } }, methods: { // 新增 addClick () { this.msgList.push(this.msg) }, // 删除 clearClick (x) { this.msgList.splice(x, 1) } } 把数组中的数据传入本地存储中本地存储需要用到两个方法： 存储数据 localStorage.setItem(&quot;键&quot;, &quot;值&quot;) 获取数据 localStorage.getItem(&quot;键&quot;) 我们写一个方法，监听数组，每次数组变化，就存储一次数据。 &lt;!--监听 msgList变化，调用存储方法--&gt; watch: { msgList () { this.savaClick() } } &lt;!--本地存储方法--&gt; savaClick () { localStorage.setItem(&#39;locaMsgList&#39;, this.msgList) } 上面的步骤完成后，就是下面的效果了。可以看到在本地存储中看到了数据的增加和删除。 优化我们可以看到，还有一些问题没有解决。比如： 每次新增完数据后，没有清空输入框。 还有就是输入框没有做判断，空数据也会录入。 当页面刚进来或者刷新时，应该默认要读取本地存储的数据； 接下来，我们就去解决他们。 addClick () { // 在新增的时候判断输入框,如果是空数据，直接 return 结束 if (!this.msg) return this.msgList.push(this.msg) // 在新增完数据后，清空 msg this.msg = &#39;&#39; }, 在实例创建的阶段已经可以访问 data, methods, watch上面的方法和数据了，将本地存储的数据赋值给 msgList。 这样就能保证即便刷新后，也能看到存储的数据。 created () { // 判断本地存储中是否有值,有值的话赋予给msgList,没有的话，删除本地存储的locaMsgList进一步防止有东西乱入 if (localStorage.getItem(&#39;locaMsgList&#39;)) { this.msgList = JSON.parse(localStorage.getItem(&#39;locaMsgList&#39;)) } else { localStorage.removeItem(&#39;locaMsgList&#39;) } } 至此，就全部结束了。 全部源代码奉上 &lt;template&gt; &lt;div&gt; &lt;h2&gt;本地存储&lt;/h2&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; placeholder=&quot;等待输入&quot;&gt; &lt;button @click=&quot;addClick()&quot;&gt;新增&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in msgList&quot; :key=&quot;index&quot;&gt; {{item}} &lt;button @click=&quot;removeClick(index)&quot;&gt;remove&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { // 双向绑定 msg msg: &#39;&#39;, // 列表循环msgList msgList: [] } }, watch: { // 监听 msgList，每次变动就去做存储数据这个事情 msgList () { this.savaClick() } }, methods: { // 新增 addClick () { // 如果 msg 为空，直接 return 结束 if (!this.msg) return this.msgList.push(this.msg) this.msg = &#39;&#39; }, // 删除 removeClick (x) { this.msgList.splice(x, 1) }, savaClick () { localStorage.setItem(&#39;locaMsgList&#39;, JSON.stringify(this.msgList)) } }, created () { // 判断本地存储中是否有值,有值的话赋予给msgList,没有的话，删除本地存储的locaMsgList进一步防止有东西乱入 if (localStorage.getItem(&#39;locaMsgList&#39;)) { this.msgList = JSON.parse(localStorage.getItem(&#39;locaMsgList&#39;)) } else { localStorage.removeItem(&#39;locaMsgList&#39;) } } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 生命周期]]></title>
    <url>%2F2019%2F12%2F09%2FVue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期：Vue 实例从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期，各个阶段有相对应的事件钩子 生命周期钩子 组件状态 最佳实践 beforeCreate 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据 常用于初始化非响应式变量 created 实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组 常用于简单的ajax请求，页面的初始化 beforeMount 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 - mounted 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 常用于获取VNode信息和操作，ajax请求 beforeupdate 响应式数据更新时调用，发生在虚拟DOM打补丁之前 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器 updated 虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 避免在这个钩子函数中操作数据，可能陷入死循环 beforeDestroy 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 常用于销毁定时器、解绑全局事件、销毁插件对象等操作 destroyed 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 - created 阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HBuilder集成的消息推送]]></title>
    <url>%2F2019%2F09%2F18%2FHBuilder%E9%9B%86%E6%88%90%E7%9A%84%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[Android 消息推送篇幅较长，但是我写得很详情，希望你能耐心看下去。 消息推送主要流程步骤: 生成签名证书 选择推送消息服务商 修改 APP 配置文件 完成 生成签名证书安装 Java 环境下载下载适用于 Mac OS X 的 Java, 傻瓜式安装，下一步到底。 这个时候我们还没有安装完成，我们还需要安装 JDK. 安装 JDK👉点击下载JDK👈 这里需要注意的是，下载的时候你必须登录 Oracal 账号才能下载，登录 Oracal 过程有点慢，还请耐心等待。如果没有Oracal账号的话，先自行注册。 安装的过程也是非常简单的，完成安装后，可以到目录中进行查看，看是否安装成功了。 我们打开终端，输入 java -version 查看java的版本。 如果成功输出了版本信息，说明 JDK 安装成功。 生成签名证书生成签名证书有多种方式，我这里介绍两种方式，使用终端或者使用 Android Studio 生成。 Android Studio 是谷歌推出的一个Android集成开发工具。 终端生成证书你需要保证你的 Java 环境已经 JDK 已经安装成功了。没有安装成功的依照前面的步骤查找原因，或者自行百度一下。 复制下面代码到终端中运行，部分参数需要自行修改。 keytool -genkey -v -alias android -keyalg RSA -validity 20000 -keystore /Users/当前用户的用户名/文件夹名字/android.keystore 这里需要注意的是，如果生成失败，请检查你的证书存放地址是否正确！！！ 参数释义: genkey : 生成文件 alias android : 表示证书的别名是android (别名最好和文件名保持一致，方便后续查询证书信息) keyalg RSA : 表示采用的RSA算法 validity 20000 : 表示证书的有效期是20000天 keystore /路径/文件名 : 前面表示生成证书存放的路径以及生成的证书文件，证书文件的后缀名随意 .keystore 或者 .jks或者不写都是可以的，反正你也打不开。 关于文件名后缀的小知识: 使用eclipse生成的密匙文件后缀为 .keystore 。 使用Android Studio生成的密匙文件后缀为 .jks 。 jks是Java密钥库(KeyStore)比较常见的一种格式(共有5种，JKS, JCEKS, PKCS12, BKS，UBER)，是JAVA的keytools证书工具支持的证书私钥格式。 其中使用哪一种key根据你最终要在那个平台发布而定，如最后要在AndriodStudio上发布就要使用.jks格式的密匙文件。 到终端中输入指令后，会让你填写一些证书信息，自行填写就好，我这是做为测试随便填写的。 刚开始会让你设定秘钥库的密码，两次密码要保持一致，以及最后还要设定密钥口令，建议和密钥库的密码保持一致。 因为输入密码因为不是明文的，所以你看不见你输入的密码，但是你不用管它，密码填写完毕后直接回车就行了。 文件生成后可以在你设定的那个目录中找到这个证书文件，这个时候就代表证书已经成功生成了。 Android Studio 生成如果没有下载 Android Studio的同学，请自行去官网下载哦。 👉点击下载Android Studio👈 下载安装步骤我就不重复了，不懂的同学可以百度。 打开 Android Studio ，新建一个项目，选择第二个 Empty Activity,点击下一步。 然后我们开始初始化项目，需要填写一些信息。 项目初始化后，点击 Build 菜单下的 Generate Signed Bundie / APK... 选择 APK 选项, 点击下一步 选择新建 Create new... 跟终端生成证书一样，填入证书信息，设置密钥 填写完成后，点击完成。签名证书也是可以在自己设置的目录路径中找到证书文件的。 查看证书在签名证书的目录下打开终端，输入如下命令查看签名证书，会让你输入刚刚你设置的密钥。密钥无误后便能看到签名证书的信息了。 keytool -list -v -keystore 证书文件 选择推送消息服务商我用的是消息推送服务商是个推，你也可以选择小米的推送，或者其他服务商的推送服务。我这里以个推为例。 打开👉个推官网👈，点击登录，没有账号的先进行注册。 找到开发者中心 -&gt; 在侧边菜单选择应用管理 -&gt; 然后点击右上角的创建应用 创建应用的过程很简单，我就不做过多阐述了。 然后找到你刚刚创建好的应用，点击应用信息 把 appid , appSecret , appKey 都记录下来。 应用签名：就是我们刚刚那个签名证书文件中的 SHA256 的值。 包名是自己填入的，一般命名规则是，公司域名反过来加上项目名称。 这里需要注意的是，APP中的包名应该要与个推中创建应用的包名保持一致。 修改 APP 配置找到 manifest.json 中的 SDK 配置。勾选个推，然后填入刚刚生成的 然后再点击发行 -&gt; 原生APP 云打包，配置如下 打包完成后，就可以使用个推推送消息了。 配置个推推送消息进入个推开发者中心，选择个推.消息推送，在应用列表中选择创建推送。 尝试简单配置推送消息 滑到最底部，点击发送预览，然后再点击确认，进行消息的推送，下面就是发送成功的预览图。 至此就告一段落了，这只是个推的简单入门，还有更多好玩有趣的就交给你去探索啦~~]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>消息推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 类的声明和使用]]></title>
    <url>%2F2019%2F09%2F17%2FTypeScript-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[类是对象具体事物的一个抽象，对象是类的具体表现 类的声明和使用类的命名规则：首字母大写，驼峰命名法。 // 示例 class SearchInfo { name: string price: number constructor (name:string, price:number) { this.name = name this.price = price } say () { console.log(&#39;Welcome&#39;) } } let goods:SearchInfo = new SearchInfo (&#39;苹果&#39;, 24) console.log(goods) goods.say() // 输出 SearchInfo { name: &#39;苹果&#39;, price: 24 } Welcome 类的修饰符 public 公共的 protected 受保护的：只能在类及其子类中访问 private 私有的：只能在类中访问 readonly 只读 // 定义一个类 class SearchPeople { // 定义属性 public sex: string protected name: string private age: number // constructor 是一种用于创建和初始化class创建的对象的特殊方法 public constructor(sex: string, name: string, age: number) { this.sex = sex this.name = name this.age = age } // 定义一个sayHello方法 public sayHello () { console.log(&#39;Welcome to my World&#39;) } // 定义一个sayBye方法 protected sayBye () { console.log(&#39;See u again&#39;) } } // 实例化类 let people1:SearchPeople = new SearchPeople(&#39;男&#39;, &#39;尼古拉斯赵四&#39;, 28) console.log(people1) console.log(people1.sex) people1.sayHello() class SearchBook { public readonly name:string = &#39;世界百科书&#39; } let book:SearchBook = new SearchBook() // book.name = &#39;百科世界书&#39; 会报错，提示 name 为只读属性 类的继承和重写类的继承用关键字 extends 需要注意的是 TypeScript 只能单重继承，不能多重继承 class MyInfo { public name:string public age:string public skill:string constructor (name:string, age:string, skill:string) { this.name = name this.age = age this.skill = skill } public interest () { console.log(&#39;唱、跳、rap、篮球&#39;) } } let MySelf:MyInfo = new MyInfo(&#39;绪锋&#39;, &#39;24&#39;, &#39;坤?&#39;) MySelf.interest() // extends 继承 class MyInfoChild extends MyInfo { public looks = &#39;handsome&#39; public smart () { console.log(&#39;我非常聪明&#39;) } // 重写 public interest () { // super 它在这里表示父类的构造函数，用来新建父类的this对象。 super.interest() console.log(&#39;我不想要唱、跳、rap、篮球了&#39;) } } let Child:MyInfoChild = new MyInfoChild(&#39;绪锋的子集&#39;, &#39;18&#39;, &#39;Double Kun&#39;) Child.smart() Child.interest() 类的命名空间为了区分相同名字的类名，我们采用以下的命名空间 namespace SearchStar { export class Dipper { public name:string = &#39;北斗星之一&#39; say () { console.log(&#39;我是天枢&#39;) } } } namespace SearchStar2 { export class Dipper { public name:string = &#39;北斗星之二&#39; say () { console.log(&#39;我是玉衡&#39;) } } } let star1:SearchStar.Dipper = new SearchStar.Dipper() let star2:SearchStar2.Dipper = new SearchStar2.Dipper() star1.say() star2.say() 接口知识关键字 interface ,可选参数用 ？ interface SearchFruits { name: string sweetness: string mouthfeel?: Boolean } let mySearchFruits:SearchFruits = { name: &#39;西瓜&#39;, sweetness: &#39;✨✨✨&#39;, mouthfeel: true } console.log(mySearchFruits) interface SearchVegetables { // 定义两个参数 理想中和现实中的 (ideal: string, reality:string): boolean } let mySearchVegetables:SearchVegetables = function(ideal: string, reality:string):boolean{ let flag = ideal.search(reality) return (flag != -1) } console.log(mySearchVegetables(&#39;补VC,美味的&#39;,&#39;美味的&#39;))]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScriptd 数组和字符串的引用类型]]></title>
    <url>%2F2019%2F09%2F17%2FTypeScript-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[字面量赋值法和构造函数赋值法 引用类型-数组字面量赋值法let arr:number[] = [] let arr:number[] = [1,2,3,4,5] let arr:Array&lt;string&gt; = [&#39;苟&#39;,&#39;利&#39;,&#39;国&#39;,&#39;家&#39;,&#39;生&#39;,&#39;死&#39;,&#39;以&#39;] let arr:Array&lt;boolean&gt; = [true, false, true] 构造函数赋值法let arr5:number[] = new Array() let arr6:number[] = new Array(1,2,3,4,5) let arr7:Array&lt;string&gt; = new Array(&#39;苟&#39;,&#39;利&#39;,&#39;国&#39;,&#39;家&#39;,&#39;生&#39;,&#39;死&#39;,&#39;以&#39;) let arr8:Array&lt;boolean&gt; = new Array(true, false, true) 引用类型-字符串和数组一样，有两种方式去赋值，字面量赋值法和构造函数赋值法。 // 字面量赋值 let name:string = &#39;LeeGeing&#39; // 构造函数赋值 let name:string = new String(&#39;LeeGeing&#39;)]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 函数的定义]]></title>
    <url>%2F2019%2F09%2F16%2FTypeScript-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[函数的定义 函数相关 函数声明方法 function add (n1:number, n2:number):number { ... } 函数表达式法 var add2 = function (n1:number, n2:number):number { ... } 箭头函数 var add3 = (n1:number, n2:number):number =&gt; { ... } 参数相关 基本使用 必须使用 function 关键字来声明函数。 function searchGoods(参数名:参数类型):函数返回类型 { ... } 形参: 顾名思义，什么形式的参数，也就是定义函数上的参数实参: 真实传递的参数，是传递过去的参数，称为实参 有可选参数的函数 参数后面跟 ? 代表参数是可选参数 function searchGoodsInfo(goods:string, price?:number):string { ... } 带默认参数的函数 在变量声明的类型后面直接跟等于，就是默认参数 function defaultGoodsInfo(goods:string=&#39;西瓜&#39;, price:number= 12 ):string { ... } 不确定参数个数的函数 用 ... 来表示参数 function searchGoodsList (...goods:string[]):string { ... } 函数的变量作用域function handleFuc2():void { var star2:string = &#39;Audrey Hepburn&#39; { let star3:string = &#39;LeeGeing&#39; console.log(&#39;我的名字是:&#39; + star3) } console.log(&#39;我喜欢的明星是:&#39; + star2) console.log(&#39;我的名字是:&#39; + star3) } handleFuc2() // 花括号内的区域就是`let`的作用域，但是在编译的过程中，会把 `let` 编译成 `var`]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typescript 的变量类型]]></title>
    <url>%2F2019%2F09%2F16%2FTypescript-%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Typescript 的变量类型 变量的类型 Typescript它有十种变量类型。 Undefined : 未定义，顾名思义当变量未定义的时候，直接使用会报错。 Number : 数字类型，支持整数类型和浮点类型，还有一个 NAN 类型。 String : 字符串,单引号或者双引号括起来的一串字符就是字符串。 Boolean : 布尔类型,它类型只有两种值，true 和 false,任务判断逻辑都会有它的参与。 enum : 枚举类型，当变量的结果是固定的几个数据时，我们就可以使用枚举类型了。 any : 任意类型，什么都可以，但是不是很建议使用哦。 void : 空类型。 Array : 数组类型。 Tuple : 元祖类型。 Null : 空类型，变量值就是空值。 变量的声明 // 声明 Number 类型 let decimal: number = 6; // 声明 String 类型 // 使用模板字符串 // 1.字符串由反引号/反引号（`）字符包围,可以跨越多行 // 2.表达式具有形式${ expr } let color: string = `白色`; let like: string = `我喜欢${ color }, 你呢？`; // 1.声明 Array 类型 // a. 变量后面直接跟元素类型然后加上[]表示 let list:number[] = [1,3,5,7,9]; // b. 使用通用数组类型Array&lt;elemType&gt; let list:Array&lt;number&gt; = [2,4,6,8]; // 2.声明 Boolean 类型，true 或者 false let isDone: boolean = false; // 3.声明 Boolean 类型，true 或者 false let isDone: boolean = false; // 4.声明 Tuple 类型,不能访问已知索引集之外的元素 let x: [string, number] = [&quot;hello&quot;, 10]; console.log(x[0].substring(1)); // OK // 5.声明 enum 类型,枚举是一种为数值集提供更友好名称的方法。 enum Color {Red, Green, Blue} let c: Color = Color.Green; // 6.声明 any 任意类型,不知道的变量类型。这些值可能是动态的内容 let notSure: any = 4; // 声明 void 类型，它有点像是相反的any，代表没有任何类型，通常视为不返回值的函数的返回类型 function warnUser(): void { console.log(&quot;This is my warning message&quot;); } let unusable: void = undefined; unusable = null;]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript开发环境和构建]]></title>
    <url>%2F2019%2F09%2F16%2FTS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开发环境和构建 安装 Typescript# 初始化 package.json npm init --y # 全局安装 Typescript npm install -g typescript # 初始化 Typescript tsc --init # 安装必备的包 # -解决模块的声明文件问题 npm install -D @types/node 尝试使用 Typescript新建一个 HelloTS.ts 文件，我们输入以下代码，进行一个简单的打印操作 // HelloTS.ts var msg:String = &#39;Hello World&#39; console.log(msg) 这样直接运行肯定是会报错的，因为不能直接运行 .ts 文件，我们需要转换成 .js 文件才能运行。 在终端输入 tsc HelloTS.ts , 然后它会在根目录生成一个 HelloTS.js 的文件。 // HelloTS.js var msg = &#39;Hello World&#39;; console.log(msg); 在终端输入 node Hello.js 运行，会看到在控制台输出了 Hello World。 一个简单的编译过程就算完成了。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏人生]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[人生就像一场不可重来的游戏，你需要好好经营这场游戏，你的付出可能和你的收获不成正比，但是你不付出就肯定没有收获。 有些人生来就有得天独厚的条件，有些人生来就比别人贫苦，这都是随机的。 而你呢，生在一个一般般的家庭中，说不上有多富有，也谈不上有多贫穷，你天赋也一般般，考试一般般，成绩一般般，上个一般般的大学，干着一般般的工作，你的生活也是一般般，你以为你的一生就这样子一般般的度过了，但你的下一代也会继承你的一般般，你儿子也会出生在一个般般的家庭…如此循环。 你以为游戏就这样了，可是这个游戏还有很多未知的地方你都没有去过，别说去过了，连看都没有看过，更糟糕的是或许你连听都没有听过。如果你还想见更多的风景，遇到更多不同的人，或许你可以努努力了。去看看更美的风景，遇到更多有趣的人，做一些与众不同的事情。]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ngnix的简单使用]]></title>
    <url>%2F2019%2F09%2F11%2FNgnix%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Nginx同Apache一样都是一种WEB服务器。基于REST架构风格，以统一资源描述符(Uniform Resources Identifier)URI或者统一资源定位符(Uniform Resources Locator)URL作为沟通依据，通过HTTP协议提供各种网络服务。 安装进入官网，下载 Nginx, 下载稳定版即可 使用安装完成后，进行解压后得到如下文件目录 然后按住 Shfit ,右键当前目录，选择 在此处打开命令窗口 // 启动 `Nginx` start nginx.exe 启动界面会一闪而过，然后打开到浏览器打开 http://localhost ，看是否成功启动了 Nginx,看到了欢迎页，那么久代表已经启动成功了。 需要注意的是，解压目录不能有中文 常用命令 名称 命令 启动nginx start nginx 修改配置后重新加载生效 nginx -s reload 重新打开日志文件 nginx -s reopen 测试nginx配置文件是否正确 nnginx -t -c nginx.conf 关闭nginx ：快速停止nginx nginx -s stop 完整有序的停止nginx nginx -s quit]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Ngnix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docsify 博客搭建]]></title>
    <url>%2F2019%2F09%2F06%2Fdocsify-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[docsify 是一个文档站点生成器。 使用起来非常简单。也是采用 Markdown 语法来编写文档。 但它与 Hexo 不同的是，Hexo 是编译完成之后再展示，会把源文件转换成 html 文件。 docsify 是在展示时再进行实时编译，这样做的好处是.md源文件不会变成 .html 文件。 安装建议docsify-cli全局安装，这有助于在本地初始化和预览网站。 npm i docsify-cli -g 然后选择目录进行初始化,这里的 .docs是指在当前目录 dosc 文件夹下面安装 docsify docsify init ./docs 初始化完成后，你可以看到 dosc 文件夹的目录结构 // 在之后init完成后，你可以看到在文件列表./docs子目录。 ---index.html 作为条目文件 ---README.md 作为主页 ---.nojekyll 阻止GitHub页面忽略以下划线开头的文件 预览项目docsify serve docs 默认地址是 http://localhost:3000，复制到浏览者打开便能看到了欢迎页面了。 给你的文档加点花样侧边栏 添加属性 loadSidebar: true &lt;!-- index.html --&gt; &lt;script&gt; window.$docsify = { loadSidebar: true } &lt;/script&gt; 新建文件 _sidebar.md 熟悉 Markdown 语法的同学，就可以直接做一个列表了。列表的内容就是你的侧边栏的内容 &lt;!-- _sidebar.md --&gt; * **这里写标题(不写也没关系，只是为了分类更清楚，双引号只是加粗的意思，就是 md 语法而已)** * [你的页面标题A](页面链接) * [你的页面标题B](页面链接) 例如： 完成之后，进行项目预览 docsify serve docs 具体效果就如下啦 添加封面 添加属性 coverpage: true &lt;!-- index.html --&gt; &lt;script&gt; window.$docsify = { coverpage: true } &lt;/script&gt; 新建文件 _coverpage.md &lt;!--logo图 可以用 &lt;svg&gt; 的方式添加图片--&gt; ![logo](_media/icon.svg) # docsify &lt;small&gt;3.5&lt;/small&gt; &gt; A magical documentation site generator. - Simple and lightweight (~21kB gzipped) - No statically built html files - Multiple themes 👨🏻‍🏫添加 vuep 实时预览代码其他类似的功能我就不重复了，这里只举一两个例子，可以对照官方文档去举一反三使用。 vuep 是一个使用实时编辑器和预览渲染Vue组件的插件。 安装 下面这些东西放在 index.html 中就行，具体放哪里，不要我说了吧，不知道的话，我会锤死你哦 &lt;link rel=&quot;stylesheet&quot; href=&quot;//unpkg.com/vuep/dist/vuep.css&quot;&gt; &lt;script src=&quot;//unpkg.com/vue&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/vuep&quot;&gt;&lt;/script&gt; 为了代码美观高亮，还可以引入如下两个插件 &lt;script src=&quot;//unpkg.com/prismjs/components/prism-bash.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/prismjs/components/prism-php.js&quot;&gt;&lt;/script&gt; 做好这些准备工作之后，就可以使用了 vuep 了。 使用 这是一个简单的例子，如果你会 vue 的一些基本语法的话，那就太棒了。 vuep中的template 属性值 = scrip中的id属性值，至于属性值叫啥名，那就由你自己去决定了。 // vuep 中的 template 属性值 = scrip 中的 id 属性值 &lt;vuep template=&quot;#demo&quot;&gt;&lt;/vuep&gt; &lt;script v-pre type=&quot;text/x-template&quot; id=&quot;demo&quot;&gt; // html 模板文件 &lt;template&gt;&lt;/template&gt; // 样式文件 &lt;sytle&gt;&lt;/style&gt; // 事件处理 &lt;script&gt; module.exports = { data: () { return { name: &#39;cinwell&#39; } } } &lt;/script&gt; &lt;/script&gt; 如果你想要使用 ES6 语法的话，那么你得引入下面这个文件 &lt;script src=&quot;//unpkg.com/babel-standalone/babel.min.js&quot;&gt;&lt;/script&gt; 如果你想要使用 JSX 语法的话，那么你得引入下面这些文件 &lt;script src=&quot;//unpkg.com/babel-standalone/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/babel-plugin-transform-vue-jsx&quot;&gt;&lt;/script&gt; 最后，你需要注意的是，&lt;script v-pre type=&quot;text/x-template&quot;&gt; 必须放在末尾！ 最后，你需要注意的是，&lt;script v-pre type=&quot;text/x-template&quot;&gt; 必须放在末尾！ 最后，你需要注意的是，&lt;script v-pre type=&quot;text/x-template&quot;&gt; 必须放在末尾！ 你可以就按照这样的格式来写就行了，正确的例子 &lt;vuep&gt;&lt;/vuep&gt; &lt;script v-pre type=&quot;text/x-template&quot;&gt; &lt;template&gt;&lt;/template&gt; &lt;style&gt;&lt;/style&gt; &lt;script&gt;&lt;/script&gt; &lt;/script&gt;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>docsify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-lazyload图片懒加载]]></title>
    <url>%2F2019%2F08%2F21%2Fvue-lazyload%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Vue模块，用于在应用程序中延迟加载图像 安装npm i vue-lazyload -S // main.js import VueLazyload from &#39;vue-lazyload&#39; Vue.use(VueLazyload, { loading: require(&#39;这里是写图片路径&#39;) }) 基本用法// old ==&gt; :src &lt;li v-for=&quot;item in discList&quot; :key=&quot;item.listennum&quot;&gt; &lt;img width=&quot;60&quot; height=&quot;60&quot; :src=&quot;item.imgurl&quot;&gt; &lt;/li&gt; // new ==&gt; v-lazy &lt;li v-for=&quot;item in discList&quot; :key=&quot;item.listennum&quot;&gt; &lt;img width=&quot;60&quot; height=&quot;60&quot; v-lazy=&quot;item.imgurl&quot;&gt; &lt;/li&gt; 简便的用法，只需要将原来的 :src 改为 v-lazy 就完成了替换。 常用 API 属性 说明 类型 默认 preLoad 预加载高度的比例 Number 1.3 error 加载失败后图像的路径 String data-src loading 加载时图像的路径 String data-src attempt 重试次数 Number 3 listenEvents 监听事件 详细说明 [&#39;scroll&#39;, &#39;wheel&#39;, &#39;mousewheel&#39;, &#39;resize&#39;, &#39;animationend&#39;, &#39;transitionend&#39;, &#39;touchmove&#39;]]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 代理请求]]></title>
    <url>%2F2019%2F08%2F21%2FVue-%E4%BB%A3%E7%90%86%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[为什么要代理请求呢？说到底还是为了解决跨域问题。 前言在 github 找到了一个网易云的后台 API 文档，自己用服务器搭建起来了一个小的接口地址。直接在浏览器中打开API 地址是可以拿到数据的，但是放在开发项目中，却出现了跨域问题。 本文就是通过代理请求去解决这个问题的。 因为没有新版的 vue-cli 没有 dev-server.js 这个文件了，因为它被合并到了 webpack.dev.conf.js 文件中。 准备工作我们需要一个 API 接口地址，以及安装 axios 插件。 安装 axios 插件。 npm install axios --save 修改 webpack.dev.conf.js// webpack.dev.conf.js const portfinder = require(&#39;portfinder&#39;) // 我们代码写在这之后 const express = require(&#39;express&#39;) const axios = require(&#39;axios&#39;) const defaultUrl = &#39;http://106.52.238.52:3000/&#39; const defaultHost = &#39;106.52.238.52:3000&#39; const app = express() const apiRoutes = express.Router() app.use(&#39;/api&#39;, apiRoutes) devServer: { // 这里新增 before 对象 before(app) { // 登录接口 // 代理的虚拟地址 app.get(&#39;/api/login/cellphone&#39;, function (req, res) { const url = defaultUrl + &#39;login/cellphone&#39; // url 真实的请求地址 axios.get(url, { // 模拟请求头 headers: { referer: defaultUrl, host: defaultHost }, // 请求参数 params: req.query }).then((response) =&gt; { res.json(response.data) }).catch((error) =&gt; { res.json(error.data) }) }) } } 修改请求文件为了代码的方便维护，我们会建一个 api 的文件夹，里面放关于请求的方法，这里我是在 src 目录下，新建了一个 api 文件夹，在文件夹中新增了 login.js 的文件 // login.js import axios from &#39;axios&#39; export function getLoginInfo (parameter) { const url = &#39;/api/login/cellphone&#39; const data = Object.assign({}, parameter) return axios.get(url, { params: data }) .then((res) =&gt; { return Promise.resolve(res.data) }) .catch((error) =&gt; { return Promise.resolve(error.data) }) } 到组件中去使用// ERR_OK 是成功状态码，自行定义即可 // data 是传入的参数，也是自行定义即可 getLoginInfo(data) .then((res) =&gt; { if (res.code === ERR_OK) { message.success(&#39;登录成功&#39;, 3, () =&gt; { this.$router.push({ path: &#39;/home&#39; }) }) } else { message.error(&#39;账号或密码错误&#39;, 3) } })]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目常用插件]]></title>
    <url>%2F2019%2F08%2F18%2F%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Vue 项目常用插件集合 babel-polyfill Babel是一个工具链，主要用于将ECMAScript 2015+代码转换为当前和旧版浏览器或环境中的向后兼容版本的JavaScript。 安装 npm install babel-polyfill --save-dev 使用 // main.js import &#39;babel-polyfill&#39; stylus 预编译 CSS 样式 安装 npm install stylus --save npm install stylus-loader --save FastClick FastClick是一个简单易用的库，用于消除物理点击和click在移动浏览器上触发事件之间300毫秒的延迟。目的是使您的应用程序感觉不那么迟钝和响应更快，同时避免干扰您当前的逻辑。 安装 npm install fastclick --save // main.js fastclick.attach(document.bdoy) 使用 // main.js import fastclick from &#39;fastclick&#39; fastclick.attach(document.body) better-scroll 为移动端（已支持 PC）各种滚动场景提供丝滑的滚动效果。 安装 npm install better-scroll --save 使用 import BScroll from &#39;better-scroll&#39;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux的基本使用]]></title>
    <url>%2F2019%2F08%2F14%2FRedux%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 介绍 或者可以用图书馆案例来理解 图片来源与技术胖 jspang.com 安装 redux npm 安装 // npm 安装 npm install --save redux yarn 安装 // yarn 安装 yarn add redux 创建 store 数据仓库安装好redux之后，在src目录下创建一个store文件夹,然后在文件夹下创建一个index.js文件。 // index.js import { createStore } from &#39;redux&#39; // 引入createStore方法 const store = createStore() // 创建数据存储仓库 export default store //暴露出去 再创建一个文件 reducer.js 文件用于管理数据 // reducer.js const defaultState = {} //默认数据 export default (state = defaultState,action)=&gt;{ //就是一个方法函数 return state } 最后将在 index.js 中引入 reducer.js // index.js import reducer from &#39;./reducer&#39; const store = createStore({ reducer, //用于 redux dev tools 调试 window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__() }) 在组件中使用仓库读取数据首先引入仓库，根据组件的位置不同，路径可能不太一样，根据实际需求来 import store from &#39;./store/index&#39; 将仓库里的数据赋值给组件的 state 数据 this.state=store.getState() 修改数据想改变Redux里边State的值就要创建Action了。Action就是一个对象，这个对象一般有两个属性，第一个是对Action的描述，第二个是要改变的值。 const action ={ type:&#39;标识名称/方法名称&#39;, value:&#39;需要传递的参数&#39; } store.dispatch(action) 然后在 reducer.js 中去接收这个参数 // reducer.js export default (state = defaultState,action)=&gt;{ if(action.type === &#39;标识名称/方法名称&#39;){ let newState = JSON.parse(JSON.stringify(state)) // 深度拷贝state // action.value 是传递过来的参数 newState.inputValue = action.value return newState } return state } 做完这一步还不够，还需要让组件进行更新 //----------关键代码-----------start this.storeChange = this.storeChange.bind(this) //转变this指向 store.subscribe(this.storeChange) //订阅Redux的状态 //----------关键代码-----------end storeChange () { // 重新setState一次就可以实现组件也是变化的。在代码的最下方，编写storeChange方法。 this.setState(store.getState()) } 🎉基础部分就是这样啦]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Updating Homebrew长时间不动的解决方法]]></title>
    <url>%2F2019%2F08%2F13%2FUpdating-Homebrew%E9%95%BF%E6%97%B6%E9%97%B4%E4%B8%8D%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Homebrew是Macs的软件包管理器，可以安装许多不同的软件，比如Git，Ruby和Node。 Homebrew可以避免与使用sudo命令安装Node等软件相关的安全问题。 安装Homebrewruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 卸载Homebrewruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; 因为每次安装应用之前，都会进行一个检查的更新，有时候网络太慢了，导致浪费很多时间花在检查更新和下载的过程中。 我们可以简单替换一下镜像源，这里我推荐的是选择 中科大的镜像 替换镜像源 第一步：替换brew.git cd &quot;$(brew --repo)&quot; git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 第二步：替换homebrew-core.git cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 最后使用进行更新 brew update 如果对替换源不满意，可以选择重置源，切换回默认的 重置镜像源、 重置brew.git cd &quot;$(brew --repo)&quot; git remote set-url origin https://github.com/Homebrew/brew.git 重置homebrew-core.git cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot; git remote set-url origin https://github.com/Homebrew/homebrew-core.git]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在React中安装Ant Design组件库]]></title>
    <url>%2F2019%2F08%2F13%2FReact%20%E5%AE%89%E8%A3%85%20antd%20%E7%BB%84%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Ant Design of React 其中包含一组高质量的组件和演示，用于构建丰富的交互式用户界面。 安装 Yarn根据操作系统选择不同的安装方式，我这里以 macOS 为例。 brew install yarn 安装完成之后可以查看 Yarn 的版本号，是否安装成功 yarn --version 若是出现版本号，那就代表安装成功了。 安装 create-react-appyarn create react-app antd-demo cd antd-demo yarn start 此时浏览器会访问 http://localhost:3000/ ，看到 Welcome to React 的界面就算成功了。 引入 antd 组件库yarn add antd 按需引入 安装 react-app-rewired customize-cra babel-plugin-import 此时我们需要对 create-react-app 的默认配置进行自定义，这里我们使用 react-app-rewired，由于新的 react-app-rewired@2.x 版本的关系，你还需要安装 customize-cra yarn add react-app-rewired customize-cra babel-plugin-import 修改 package.json 配置 /* package.json */ &quot;scripts&quot;: { &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot; } 创建 config-overrides.js 文件 const { override, fixBabelImports } = require(&#39;customize-cra&#39;) module.exports = override( fixBabelImports(&#39;import&#39;, { libraryName: &#39;antd&#39;, libraryDirectory: &#39;es&#39;, style: &#39;css&#39;, }), ) 最后重启 yarn start 访问页面，antd 组件的 js 和 css 代码都会按需加载]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>antd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 父子组件传值]]></title>
    <url>%2F2019%2F08%2F09%2FReact-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[父组件可以通过属性的方式，向子组件传递参数 父组件向子组件传递参数// 父组件 &lt;AddList list={this.state.list} /&gt; // 子组件接收参数 {this.props.list} 子组件向父组件传递参数 React 是单向数据流，并不支持子组件修改父组件的数据。 如果需要修改，那也是现在父组件中去修改，子组件只是调用父组件传过来的方法而已。 举个🌰 // 父组件向子组件传递一个方法 &lt;AddList delfuc={this.delData} /&gt; delData (index) { conosle.log(index) } // 子组件接收方法 &lt;div onClick={this.delData.bind(this, &#39;参数&#39;)&gt;Childer-Component&lt;/div&gt; delData (parameter) { // 接收父组件的方法，并传递参数 this.props.delfuc(parameter) }]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React组件的使用]]></title>
    <url>%2F2019%2F08%2F09%2FReact%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[React 组件的使用与 Vue 稍微有些不同。 React 没有注册组件这个过程，引入就可以直接使用了 // 引入子组件 import AddList from &#39;./component/AddList&#39; 然后直接在 JSX 中直接使用 &lt;AddList/&gt;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vue中运用Swiper]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%9C%A8Vue%E4%B8%AD%E8%BF%90%E7%94%A8Swiper%2F</url>
    <content type="text"><![CDATA[Swiper常用于移动端网站的内容触摸滑动Swiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。 安装npm install vue-awesome-swiper --save 引入引入方式有两种，一种全局引入，一种为组件引入，根据自己需求去引入文件。 全局引入 import Vue from &#39;vue&#39; import VueAwesomeSwiper from &#39;vue-awesome-swiper&#39; import &#39;swiper/dist/css/swiper.css&#39; Vue.use(VueAwesomeSwiper) 组件引入 import &#39;swiper/dist/css/swiper.css&#39; import { swiper, swiperSlide } from &#39;vue-awesome-swiper&#39; export default { components: { swiper, swiperSlide } } 使用&lt;template&gt; &lt;swiper :options=&quot;swiperOption&quot;&gt; &lt;!-- 轮播 --&gt; &lt;swiper-slide&gt;I&#39;m Slide 1&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I&#39;m Slide 2&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I&#39;m Slide 3&lt;/swiper-slide&gt; &lt;!-- 可选配置 --&gt; &lt;!-- 分页器 --&gt; &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; &lt;!-- 前进后退按钮 --&gt; &lt;div class=&quot;swiper-button-prev&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt; &lt;!-- 滚动条 --&gt; &lt;div class=&quot;swiper-scrollbar&quot; slot=&quot;scrollbar&quot;&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/template&gt; swiperOption: { // 分页器 pagination: { el: &#39;.swiper-pagination&#39; }, // 前进后退按钮 navigation: { nextEl: &#39;.swiper-button-next&#39;, prevEl: &#39;.swiper-button-prev&#39; }, // 是否无限循环 loop: true, // 切换方式 effect: &#39;cube&#39; } 一个基本的轮播就做好了，有关于更多详细API，请移步官网 API。Swiper4 API : https://www.swiper.com.cn/api/navigation/355.html]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>swiper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hello World]]></title>
    <url>%2F2019%2F08%2F06%2FReact-Hello-World%2F</url>
    <content type="text"><![CDATA[React 目录详解 我们初始化 React 项目后，可以看一下 React 的目录。 node_moudules : 用于存放项目的依赖包 public : 公共文件 src : 平时我们编写的代码就都存储在这个文件夹内 .gitignore : 忽略提交文件的配置文件 package-lock.json ：这个文件用一句话来解释，就是锁定安装时的版本号，并且需要上传到git，以保证其他人再npm install 时大家的依赖能保证一致。 package.json : 这个文件是webpack配置和项目包管理文件，项目中依赖的第三方包（包的版本）和一些常用命令配置都在这个里边进行配置，当然脚手架已经为我们配置了一些了，目前位置，我们不需要改动。如果你对webpack了解，对这个一定也很熟悉。 项目开始的时候，可以删除 src 文件夹目录下的所有文件，自己新建一个 index.js 以及 App.js. // index.js import React from &#39;react&#39; import ReactDOM from &#39;react-dom&#39; import App from &#39;./App&#39; ReactDOM.render(&lt;App /&gt;,document.getElementById(&#39;root&#39;)) // App.js import React, {Component} from &#39;react&#39; class App extends Component{ render(){ return ( &lt;div&gt; Hello World &lt;/div&gt; ) } } export default App 运行项目，就应该能看到页面上显示的 “Hello World” 了]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React JSX]]></title>
    <url>%2F2019%2F08%2F06%2FReact-JSX%2F</url>
    <content type="text"><![CDATA[React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。 在 JSX 中嵌入变量const name = &#39;Josh Perez&#39;; const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;; 插入表达式function formatName(user) { return user.firstName + &#39; &#39; + user.lastName; } const element = ( &lt;h1&gt; Hello, {formatName(user)}! &lt;/h1&gt; ); JSX 特定属性你可以通过使用引号，来将属性值指定为字符串字面量 const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;; 使用大括号，来在属性值中插入一个 JavaScript 表达式 const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt; 因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建 React 项目]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-React-%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[创建一个 React 项目有好几种方法，但是我唯独喜欢搭建本地开发环境的这种方式去创建。 // 创建 react 项目 npx create-react-app my-app // 进入到项目目录 cd my-app // 启动项目 npm start]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue小白の练手项目之旅]]></title>
    <url>%2F2019%2F08%2F01%2FVue%E5%B0%8F%E7%99%BD%E3%81%AE%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[其实很久之前就接触过Vue,但是没有经过系统的学习，只有一些零散的知识，为了更加对 Vue 有一个全面的了解，所以我决定做一个练手的项目— —“ToDoList”。 前言项目地址 “ToDoList”涉及到的知识点涵盖了大部分Vue的 API。 计算属性 监听属性 生命周期 Class 与 Style 绑定 条件渲染 列表渲染 事件处理 表单输入绑定 组件基础 Prop 过渡动画 时间控件,还有弹窗等采用了比较热门的库 “Vux” 数据保留在 “Local Storage” 中，刷新之后也不会丢失数据 数据管理用的 “Vux” 先来看看完成后的预览效果。 项目预览 实现的功能 任务根据时间排序 完成任务 删除任务 任务列表存储到本地 你可能会遇到的问题复杂数据类型在栈中存贮的是指针,所以赋值给新的变量也会改变原始的变量值. 我遇到的这个场景在于把时间戳转为时间格式的时候，为了不影响原有的数据，我已经进行过数据拷贝了，但发现还是会影响到原来的数据，我百思不得其解，后面在思否论坛上看了问题。我觉得说得挺好的。 详情见 props 传值的问题 解决方案： 可以手动深度克隆一个复杂的数据出来,循环或者递归都行 强大的 JSON.stringify 和 JSON.parse ，将对象或者数组先转为字符串然后再转回来，我采用的就是这种方法。 本地存储数据中的数据已经发生了更改，但是却不会触发 watch 侦听属性 这个问题遇到的场景在设置完成任务的时候，执行的方法已经让本地存储数据发生了改变，但是页面上却没有任务动静，怎么也监听不到这个事件，后面在前辈的帮助下，重新查阅了 watch 的 API。 解决方案： 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 watch: { c: { handler: function (val, oldVal) { /* ... */ }, deep: true } } 这些都不是什么大问题，大多数是因为自己没有仔细参阅官方文档手册而发生的问题，但是出现问题并不要灰心气馁，重要的是你如何去解决问题。填的坑多了，自然也就熟悉了。 最后的总结详细的教程是没有的😂，我不太会写，我只能分享我的心得，大家可与自己去实现一个这样的练手小项目。 在做项目之前，首先要有一个整体的思路，你想要一个什么样的项目出来，你需要怎么去实现它，心里应该要有一个底，而不是盲目的去做，想到什么就去做什么。 比如，我做这些项目之前，我首先要想的是前端页面布局之类的，我想展示一个怎样的页面出来，怎么看着简洁舒服。我会在本子上画一个简图，完成静态的页面之后，就开始做功能，我需要实现哪些功能，我应该怎么去实现这个功能，为了实现这个功能我会用到哪些 API的，等等。 最后的最后欢迎👉star 👈 ,我知道我还有很多不足的地方，代码也有很多可以优化的地方。大家可以根据我实现的功能自己去独立完成这个小项目，我的项目仅作为一个参考，只有自己独立完成以后才知道它带给你的收获有多少。 再次附上项目地址：https://github.com/mraing/TodoList 谢谢大家支持，小伙们加油呀ヽ( ^∀^)ﾉ]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引入 VUX 库]]></title>
    <url>%2F2019%2F07%2F22%2F%E4%BD%BF%E7%94%A8-Vux-%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[基于webpack + vue-loader + vux可以快速开发移动端页面，配合vux-loader方便你在WeUI的基础上定制需要的样式。 安装 Vuxnpm install vux --save 安装less-loader为了正确编译less源码 npm install less less-loader --save-dev 安装 yaml-loader为了正确进行语言文件读取 npm install yaml-loader --save-dev 安装vux-loader保证了组件按需使用，因此不用担心最终打包了整个vux的组件库代码。 npm install vux-loader --save-dev 安装完这些依赖后，还有些文件需要修改下。 修改 webpack.base.conf.js为了降低使用成本及不侵入原来配置，只需要调用merge方法对原来webpack配置进行操作 const webpackConfig = {} // 原来的 webpack.base.js 配置 把原来的 module.exports 替换成 const webpackConfig 引入vux-loaderconst vuxLoader = require(&#39;vux-loader&#39;) 调用merge方法module.exports = vuxLoader.merge(webpackConfig, { options: {}, plugins: [{ name: &#39;vux-ui&#39; }] }) 最后重新运行启动项目npm run dev 不知道自己有没有引入成功的话，可以试一下引入一个简单的按钮组件尝试一下。 引入按钮组件并注册 import { XButton } from &#39;vux&#39; export default { components: { XButton } } 使用组件 &lt;template&gt; &lt;div&gt; hello vux &lt;x-button type=&quot;primary&quot; text=&quot;按钮&quot; &gt; &lt;/x-button&gt; &lt;/div&gt; &lt;/template&gt; 我们可以看到按钮能被正常加载，并且控制台也没有任何报错，这个时候就说明 VUX 引入成功了。 至此结束 ✧(≖ ◡ ≖✿)嘿嘿]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 真机调试]]></title>
    <url>%2F2019%2F07%2F14%2FVue-%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[跨平台预览在 package.json 文件中，修改代码如下 &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --inline --progress --config build/webpack.dev.conf.js&quot; }, 这样的话，其他同局域网的设备也就都能通过本机的 IP 地址进行访问了. 项目正式上线在 config 目录下的 idnex.js 文件中找到 assetsPublicPath: &#39;/(目录名称)&#39;, 如果是 根目录的话，就直接 / 就行了]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex的简单使用]]></title>
    <url>%2F2019%2F07%2F10%2FVuex%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则： 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。 核心概念 State：存放公有的数据 Getter：类似于计算属性 Mutation：对数据同步的改变 Action：异步的方法 安装 Vuexnpm install vuex --save 实例化一个 Vuex 新建一个文件夹 store ,创建一个 index.js 的文件,实例化 Vuex import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) export default new Vuex.Store({ state: { // 这里写数据的初始状态,类似于 data }, mutations: { // 更改变化,类似于 methods, 同步执行 }, getters: { // 计算属性，类似于computed }, actions: { // 类似于 mutations, 不过是异步操作的 } }) 然后在 mian.js 中使用此文件 // 引入 vuex import store from &#39;./store&#39; new Vue({ el: &#39;#app&#39;, store, components: { App }, template: &#39;&lt;App/&gt;&#39; }) 如何使用 state // 直接在组件内使用 this.$store.state.count // 通过映射的方式 import {mapState} from &#39;vuex&#39; export default { computed: { ...mapState({ todolist: state =&gt; state.todolist }) } } mutations // 直接在组件内使用 this.$store.commit(&#39;方法名称&#39;, 参数) // 通过映射的方式 import { mapMutations } from &#39;vuex&#39; ...mapMutations([ &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.commit(&#39;increment&#39;)` // `mapMutations` 也支持载荷： &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#39;incrementBy&#39;, amount)` ]) getters // 在组件中直接使用 this.$store.getters.doneTodosCount // 通过映射的方式 import { mapGetters } from &#39;vuex&#39; computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &#39;doneTodosCount&#39;, &#39;anotherGetter&#39;, // ... ]) }]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019/07/08]]></title>
    <url>%2F2019%2F07%2F08%2F2019-07-10%2F</url>
    <content type="text"><![CDATA[2019/07/08 🌧 雨 起床刷牙出门上班，和往常一样，今天也是迟到的一天，并不是离公司的路程远，而是我已经习惯迟到了。 后面楼某户人家的老人去世了，我想他是安逸的，毕竟已经看到了这个盛世，没有什么遗憾了，唯一要说的遗憾就是没有多享几年福吧。在农村里，有人去世会整晚整晚的放奠歌，但这户人家到晚上十一二点的样子就安静下来了，我反正也会那个时候才睡，虽然就在楼下，但也并不扰民，或许这样才会更加值得人们去尊敬吧，平时默默无闻，死后倒风光了一把，街坊邻居都知道这家是谁去世了。 感觉人这一辈子过得好快啊，一二十年，三四十年，四五十年，也不过眨眼之间。说什么生活难的，生活苦的，还不是照样过来了。 我总是给自己定制计划，可事实上我并不会完全按照计划去行事，因为我就是这样的人呀，随心所欲。但是人活在社会，并不能一直随心所欲的活着，你会有压力，你房租的压力，支付宝里花呗的压力。 有人喜欢拿别人跟自己比较，别人比自己漂亮，别人比自己有钱，别人都已经买房买车了等等，我不喜欢比，我喜欢做自己，别人是别人，我是我，别人能做的事情，虽然我可以做到，但是我不想做我就不会去做，说到底还是因为懒。我懒得去争，我懒得去做，我懒得比。我想就这样默默无闻的过一生也挺好，与世无争，一副岁月静好的样子，即便死去也会很快从别人的记忆中消失。 以前看书上写着，人生活在社会上，是由多个角色组成的，一个儿子的角色，一个哥哥的角色，一个男朋友的角色，可是我感觉演的一点都不像，我没有做好一个儿子应尽的义务，也没有好好照顾妹妹，更没有承担起一个男朋友的责任。]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue快捷引用目录]]></title>
    <url>%2F2019%2F06%2F29%2FVue%E5%BF%AB%E6%8D%B7%E5%BC%95%E7%94%A8%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Vue 中，有时候需要经常引用到某个文件，每次输入一长串的目录地址，不是很方便。这时我们可以给目录取一个别名，快捷引用目录。 首先找到 build 目录下面的 webpack.base.conf.js 文件。 在文件中找到 resolve: { extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;], alias: { &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;, &#39;@&#39;: resolve(&#39;src&#39;) } }, 在 alias 中新增一个别名，例如： resolve: { extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;], alias: { &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;, &#39;@&#39;: resolve(&#39;src&#39;), &#39;styles&#39;: resolve(&#39;src/assets/styles&#39;) } } 然后就可以这样去引用它，比如原来我们需要引入的地址是这样的： &lt;!--old--&gt; import &#39;../../../styles/reset.css&#39; 现在我们只需要这样做： &lt;!--new--&gt; import &#39;styles/reset.css&#39; 需要注意的一点是，如果是在 css样式中引入别的样式表，需要在前面加上一个 ~ 符号，例如： &lt;style lang=&quot;stylus&quot; scoped&gt; @import &#39;~styles/varibles.styl&#39; &lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue动态渲染组件]]></title>
    <url>%2F2019%2F06%2F25%2FVue%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[动态组件，通过 is 去动态渲染组件 &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt; 比如下面这个例子 &lt;!--父组件--&gt; &lt;div id=&quot;app&quot;&gt; &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt; &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt; &lt;/div&gt; Vue.component(&quot;child-one&quot;, { template: `&lt;div v-once&gt;one,one&lt;/div&gt;` }); Vue.component(&quot;child-two&quot;, { template: `&lt;div v-once&gt;two-two&lt;/div&gt;` }); var vm = new Vue({ el: &quot;#app&quot;, data: { type: &#39;child-one&#39; }, methods:{ handleClick (){ this.type = (this.type === &#39;child-one&#39;? &#39;child-two&#39;: &#39;child-one&#39;); } } }); 在子组件中添加 v-once 有助于提高静态页面的渲染速度。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 插槽]]></title>
    <url>%2F2019%2F06%2F25%2FVue-%E6%8F%92%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[我们定义一个子组件后，有时候还需要往子组件中插入 html，这时我们就需要用到 slot 。 基本用法&lt;div id=&quot;app&quot;&gt; &lt;child&gt; &lt;h1&gt;Mr.Aing&lt;/h1&gt; &lt;/child&gt; &lt;/div&gt; Vue.component(&quot;child&quot;, { template: `&lt;div&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;slot&gt;默认内容&lt;/slot&gt; &lt;/div&gt;` }); var vm = new Vue({ el: &quot;#app&quot;, data: {} }); 设置默认值我们还可以设置默认slot的默认值。如果父组件中插入的 html没有值，然后可以在子组件中的 slot标签中写入默认值。 进阶用法我们又有一个需求，在父组件中，我们需要在子组件中插入头部和尾部标签。这时我们就需要用 name 属性。 &lt;div id=&quot;app&quot;&gt; &lt;child&gt; &lt;div class=&quot;header&quot; slot=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;footer&quot; slot=&quot;footer&quot;&gt;footer&lt;/div&gt; &lt;/child&gt; &lt;/div&gt; Vue.component(&quot;child&quot;, { template: `&lt;div&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/div&gt;` }); var vm = new Vue({ el: &quot;#app&quot;, data: {} }); 新语法&lt;!--父组件--&gt; &lt;child&gt; &lt;template v-slot:head=&quot;{ msg }&quot;&gt; &lt;p&gt;new: i&#39;m new slot - {{ msg }}&lt;/p&gt; &lt;/template&gt; &lt;/child&gt; &lt;!--子组件--&gt; &lt;div&gt; &lt;slot name=&quot;head&quot; v-for=&quot;item in items&quot; :msg=item &gt; 默认值 &lt;/slot&gt; &lt;/div&gt; 上述语法是新语法，注意双花括号和单括号的切换使用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非父子组件之间的通讯]]></title>
    <url>%2F2019%2F06%2F25%2F%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[Bus/总线/发布订阅模式/观察者模式 Bus/总线/发布订阅模式/观察者模式在 vue 的prototype上挂载了一个 bus 的属性，这样做的目的就是让所有的 Vue 实例都带有这个属性 Vue.prototype.bus = new Vue(); 在子组件上触发事件时，通过bus.$emit这个方法向外触发事件. this.bus.$emit(&quot;change&quot;, this.selfContent); 在子组件上的生命周期-挂载时接收这个通知 mounted:function() { var _this = this; this.bus.$on(&quot;change&quot;, function(msg) { console.log(msg+&#39;被挂载时执行这个函数&#39;); }); } 整体代码如下： &lt;div id=&quot;app&quot;&gt; &lt;div&gt;父子组件通讯：Bus/总线/发布订阅模式/观察者模式&lt;/div&gt; &lt;child content=&quot;LEE&quot;&gt;&lt;/child&gt; &lt;child content=&quot;DELL&quot;&gt;&lt;/child&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;script&gt; //在 vue 的prototype上挂载了一个 bus 的属性，这样做的目的就是让所有的 Vue 实例都带有这个属性 Vue.prototype.bus = new Vue(); Vue.component(&quot;child&quot;, { props: { content: String }, data() { return{ selfContent: this.content } }, template: &#39;&lt;div @click=&quot;handleClick&quot;&gt;{{selfContent}}&lt;/div&gt;&#39;, methods: { handleClick() { // console.log(this.content); console.log(&quot;触发 methods&quot;); this.bus.$emit(&quot;change&quot;, this.selfContent); //this.bus 指的是挂载在 Vue 上的一个属性，每个实例上都有会 bus 这个属性，bus 又是 Vue 的实例，所以bus 上也会有 $emit 这个方法，我们就可以通过这个方法向外触发事件 } }, //生命周期-被挂载时执行这个函数 mounted:function() { var _this = this; this.bus.$on(&quot;change&quot;, function(msg) { console.log(msg+&#39;被挂载时执行这个函数&#39;); _this.selfContent = msg; }); } }); //实例化Vue var vm = new Vue({ el: &quot;#app&quot;, }); &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件使用过程中的小坑]]></title>
    <url>%2F2019%2F06%2F20%2FVue%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[模板组件渲染出错 在使用组件的过程中，会碰到耦合性特别强的标签，比如 ul,li 、 ol,li 、select,option 、table tr, td 标签等。 如果我们直接用里面的子标签做为组件使用，就可能会出现问题。 例如下面这个表格 &lt;!--html--&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;123&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;123&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;123&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; 在网页上展示的 DOM 结构为如下图所示，这样是没有问题的。 当我们把 td 当做一个子组件去使用时，就可能会出现下面这种情况。 &lt;!--html--&gt; &lt;table&gt; &lt;tr&gt;&lt;my-td&gt;&lt;/my-td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;my-td&gt;&lt;/my-td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;my-td&gt;&lt;/my-td&gt;&lt;/tr&gt; &lt;/table&gt; //注册全局组件 Vue.component(&quot;my-td&quot;,{ &quot;template&quot;: &quot;&lt;td&gt;123&lt;/td&gt;&quot; }); //创建 Vue 实例 var vm = new Vue({ el: &quot;#app&quot;, data: {} }); 我们注册了一个全局组件，组件内容就是 td 标签，然后放入到页面中去使用它，然后我们到页面上查看 DOM 结构，发现有问题。 在 H5的规范里面，我们需要遵循标签的嵌套，table &gt; tr &gt;tr 。但是现在table tr 并没有包裹住 td 标签。 那么如果解决这种情况呢？ Vue 给我们提供了解决方法，既然对于某些标签有严格的嵌套标准，那么我们便去遵守它，还是和原来的代码一样。只不过 DOM 结构有些不同。 &lt;table&gt; &lt;tr&gt;&lt;td is=&quot;my-td&quot;&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td is=&quot;my-td&quot;&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td is=&quot;my-td&quot;&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; 用 is 表示指向这个组件，这样符合H5的代码标准，又能保证我们能正常使用组件。 同理，对于其他耦合性较强的标签，都可以使用 is 属性进行模板组件的使用。 子组件数据渲染出错在子组件中定义 data 时，data 必须是个函数。 还是刚刚那个例子，这时我们在 data 中定义一个content 参数，然后在模板中调用它。 //注册全局组件 Vue.component(&quot;my-td&quot;,{ data: { content: &#39;123&#39; }, &quot;template&quot;: &quot;&lt;td&gt;{{ content }}&lt;/td&gt;&quot; }); 运行到浏览器中，我们会发现控制台报错了。 vue:6 ReferenceError: content is not defined 提示我们 content 没有定义，这是因为在子组件中定义 data 时，data 必须是个函数。 所以，我们应该这样把 data 改为一个函数，这样就能正常渲染出数据了。 //注册全局组件 Vue.component(&quot;my-td&quot;,{ data(){ return { content: &#39;123&#39; } }, &quot;template&quot;: &quot;&lt;td&gt;{{ content }}&lt;/td&gt;&quot; }); 操作 DOMvue 官方不推荐我们去操作 DOM，取而代之的是数据绑定，但是在处理某些极为复杂的情况时，又必须得去操作 DOM ,所以 vue 给我们提供了 ref 属性。 &lt;!--html--&gt; &lt;div @click=&quot;handleClickMe&quot; ref=&quot;hello&quot;&gt;Click Me&lt;/div&gt; //JS methods:{ handleClickMe() { console.log(this.$refs.hello); } } 打印结果如下,它会把这个 DOM 节点都打印输出。 &lt;div&gt;Click Me&lt;/div&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vueの计算属性computed]]></title>
    <url>%2F2019%2F06%2F19%2Fvue%E3%81%AE%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed%2F</url>
    <content type="text"><![CDATA[对于任何复杂逻辑，你都应当使用计算属性 语法&lt;!--html--&gt; &lt;div&gt;计算属性 : {{fullName}}&lt;/div&gt; //js var vm = new Vue({ el: &quot;#app&quot;, data: { firstName: &quot;Lee&quot;, lastName: &quot;Geing&quot;, fullName: &quot;LeeGeing&quot; }, //计算属性 computed: { fullName:function() { return this.fullName = this.firstName + this.lastName; } } }); 计算属性 computed 有缓存的机制，如果依赖的值没有变化，是不会进行改变的，这样做的好处是减少性能的损耗。 计算属性缓存和方法的区别计算属性 computed : 是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 fullName 还没有发生改变，多次访问 fullName 计算属性会立即返回之前的计算结果，而不必再次执行函数。 方法 methods : 数据的每次变换都会重新加载一次。 监听 watch: 只有变换的那个数据会被重新加载。 完整代码如下 &lt;!--html--&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 计算属性 --&gt; &lt;div&gt;计算属性 computed :有缓存的机制，如果依赖的值没有变化，是不会进行改变的，这样做的好处是减少性能的损耗&lt;/div&gt; &lt;div&gt;计算属性 : {{fullName}} {{age}}&lt;/div&gt; &lt;hr&gt; &lt;!-- 方法属性 --&gt; &lt;div&gt;通过方式去实现的数据更改，改变数据会重新加载一次 DOM&lt;/div&gt; &lt;div&gt;方法 : {{ fullNameFuc() }} {{age}}&lt;/div&gt; &lt;hr&gt; &lt;!-- 监听 --&gt; &lt;div&gt;监听 : {{ fullName2 }} {{age}}&lt;/div&gt; &lt;/div&gt; //js var vm = new Vue({ el: &quot;#app&quot;, data: { firstName: &quot;Lee&quot;, lastName: &quot;Geing&quot;, fullName2: &quot;LeeGeing&quot;, age: 23 }, //计算属性 computed: { fullName:function() { console.log(&quot;computed 执行了一次&quot;); return this.firstName + this.lastName; } }, //方法 methods: { fullNameFuc:function() { console.log(&quot;methods 执行了一次&quot;); return this.firstName + this.lastName; } }, //监听 watch: { //监听firstName firstName:function(){ console.log(&quot;监听firstName 执行了一次&quot;); this.fullName2 = this.firstName + this.lastName; }, //监听lastName lastName:function(){ console.log(&quot;监听lastName 执行了一次&quot;); this.fullName2 = this.firstName + this.lastName; } } });]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件简单传值]]></title>
    <url>%2F2019%2F06%2F19%2FVue%E7%BB%84%E4%BB%B6%E7%AE%80%E5%8D%95%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[父组件传值到子组件通过 props 进行父组件向组件传值。 首先，在子组件中绑定参数，参数名字自拟。 &lt;子组件名称 :content=&quot;参数值&quot;&gt;&lt;/子组件名称&gt; 然后在子组件中用 props 属性接收参数。 props: [&quot;content&quot;] 最后就在页面中调用参数 &lt;div&gt;{{content}}&lt;/div&gt; 例如下面这个例子 &lt;!--html--&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;search&quot; v-model=&quot;value&quot; /&gt; &lt;button @click=&quot;addList&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{ item }}&lt;/li&gt; --&gt; &lt;todo-item v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; :content=&quot;item&quot;&gt;&lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; //组件模板 var todoItem = { props: [&quot;content&quot;], template: &quot;&lt;li&gt; {{content}} &lt;/li&gt;&quot; }; 、、实例化对象 var app = new Vue({ el: &quot;#app&quot;, data() { return { value: &quot;&quot;, list: [] }; }, methods: { addList() { this.list.push(this.value); this.value = &quot;&quot;; } }, components: { todoItem } }); 子组件传值给父组件上一个例子是点击提交，生成一条列表。现在我们需要点击当前某一条列表，删除列表。 我们还是参考上一个例子来完成这个效果。其中就需要用到子组件传值给父组件。 我们先给子组件绑定事件 template: &quot;&lt;li @click=&#39;handleItems&#39;&gt; {{content}} &lt;/li&gt;&quot;, 然后在子组件的中的 methods编写事件 子组件可以使用 $emit 触发父组件的自定义事件 methods:{ handleItems() { this.$emit(&#39;delete&#39;); } } 在父组件中进行绑定事件 &lt;todo-item v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; :content=&quot;item&quot; @delete=&quot;handleItemsDelete&quot;&gt;&lt;/todo-item&gt; 然后在父组件中 methods 编写事件方法 //清空列表 methods: { handleItemsDelete(index){ this.list = []; } } 这样可以实现点击列表，可以清空列表。但是这不是我们想要的效果。我们需要点击哪一条列表，哪一条列表就消失，而不是全部消失。 做到这样的效果，我们需要知道列表的下标才好去操作某一条数据。 再回到刚刚父组件传值给子组件的那个，我们还需要多穿一个下标值给子组件。 &lt;todo-item v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; :content=&quot;item&quot; :index=&quot;index&quot; @delete=&quot;handleItemsDelete&quot;&gt;&lt;/todo-item&gt; 我们多绑定一个 index属性，做为传下标给子组件的参数。 子组件接收值，并把值再传回给父组件 props: [&quot;content&quot;,&quot;index&quot;], methods:{ handleItems(){ this.$emit(&#39;delete&#39;,this.index); } } 父组件在编写事件时，把值传入handleItemsDelete方法，并进行删减操作。 methods: { handleItemsDelete(index){ this.list.splice(index,1); } } 全部代码如下 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;search&quot; v-model=&quot;value&quot; /&gt; &lt;button @click=&quot;addList&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;todo-item v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; :content=&quot;item&quot; :index=&quot;index&quot; @delete=&quot;handleItemsDelete&quot;&gt;&lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; var todoItem = { props: [&quot;content&quot;,&quot;index&quot;], template: &quot;&lt;li @click=&#39;handleItems&#39;&gt; {{content}} &lt;/li&gt;&quot;, methods:{ handleItems(){ this.$emit(&#39;delete&#39;,this.index); } } }; var app = new Vue({ el: &quot;#app&quot;, data() { return { value: &quot;&quot;, list: [] }; }, methods: { addList() { this.list.push(this.value); this.value = &quot;&quot;; }, handleItemsDelete(index){ this.list.splice(index,1); } }, components: { todoItem } }); 👨‍👦父子组件之间的传值需要注意的事项Vue提倡的是单向数据流，即父组件可以传值给子组件，但是子组件不能去直接修改父组件传过来的值。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 动态绑定背景图片]]></title>
    <url>%2F2019%2F06%2F17%2Fvue-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[:style=&quot;{background: &#39;url(&#39; + citem.iconImg + &#39;) 12.5px 50% / 25px no-repeat&#39;}&quot;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 热更新失效]]></title>
    <url>%2F2019%2F06%2F17%2FVue-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[使用vue-router时，对应的页面需要区分大小写，虽然不会报错，但是会影响热更新。 问题描述今天使用 vue 框架做项目时，发现热更新失效了。有些页面可以使用热更新，有些页面不能使用热更新，找了半天终于发现问题了。 问题解决使用vue-router时，对应的页面需要区分大小写，虽然不会报错，但是会影响热更新。 使用vue-router时，对应的页面需要区分大小写，虽然不会报错，但是会影响热更新。 使用vue-router时，对应的页面需要区分大小写，虽然不会报错，但是会影响热更新。 重要的事情说三遍！！ 此情况同样适用于.vue文件里组件的引用，大小写不一致的话，也会导致子组件热修复失效。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2F2019%2F06%2F12%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git 常用命令大集合 基础篇提交更新git commit 创建分支git branch &lt;分支名称&gt; 切换分支git checkout &lt;分支名称&gt; 创建一个新的分支同时切换到新创建的分支的话，可以使用 git checkout -b &lt;分支名称&gt; 分支与合并新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。 merge合并分支咱们先来看一下第一种方法 —— git merge。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。” 换回分支 git checkout &lt;分支名称&gt; 再合并master分支 git merge master 再切换master分支 git checkout master 再合并分支 git merge &lt;分支名称&gt; rebase合并分支和 merge 用法类似。不过语法关键字不一样。 git rebase &lt;分支名称&gt; 高级篇HEAD 指向如果想看 HEAD 指向，可以通过查看. cat .git/HEAD 如果 HEAD 指向的是一个引用，还可以用查看它的指向。 git symbolic-ref HEAD 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。 我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。 HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。 HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。 通过哈希值指定提交记录。每个提交记录的哈希值显示在代表提交记录的圆圈中。 相对引用通过指定提交记录哈希值的方式在 Git 中移动不太方便。用 git log来查查看提交记录的哈希值。 git log Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。 通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。 使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。 相对引用非常给力，这里我介绍两个简单的用法： 使用 ^ 向上移动 1 个提交记录 使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3 首先看看操作符 (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。 所以 master^ 相当于“master 的父节点”。 也可以将 HEAD 作为相对引用的参照,我们可以一直使用 HEAD^ 向上移动。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue引入Mint-UI框架]]></title>
    <url>%2F2019%2F06%2F12%2FVue%E5%BC%95%E5%85%A5Mint-UI%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[基于 Vue.js 的移动端组件库 安装 npm i mint-ui -S 全局引入 // main.js import Vue from &#39;vue&#39; import MintUI from &#39;mint-ui&#39; import &#39;mint-ui/lib/style.css&#39; import App from &#39;./App.vue&#39; Vue.use(MintUI) new Vue({ el: &#39;#app&#39;, components: { App } })]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Mint-UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue路由重定向]]></title>
    <url>%2F2019%2F06%2F12%2FVue%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[重定向路由，刚进来就默认显示其中的一个子页面。 // 路由属性 redirect: &#39;重定向地址&#39; // router.js import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import HelloWorld from &#39;@/components/HelloWorld&#39; import Switch from &#39;@/components/mint-ui-switch&#39; Vue.use(Router) export default new Router({ routes: [ { path: &#39;/&#39;, name: &#39;HelloWorld&#39;, component: HelloWorld, redirect: &#39;/switch&#39;, children:[{ path:&#39;/switch&#39;, component:Switch }] } ] })]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Mui tabber]]></title>
    <url>%2F2019%2F05%2F17%2F%E4%BD%BF%E7%94%A8Mui-tabber%2F</url>
    <content type="text"><![CDATA[通过DIV模拟一个独立页面，通过DIV的显示、隐藏模拟不同页面的切换，典型的SPA模式. 使用场景这种模式适合简单业务系统，因为每个选项卡内容要写在一个DIV中，若逻辑复杂，会导致当前页面DOM结构繁杂，造成webview响应缓慢，甚至崩溃；因此若系统较复杂，需要下拉刷新等操作，推荐使用webview模式的选项卡； 引入mui.js如果不是在 HBuilder 中新建的 MUI 项目，那么需要自行下载，点我下载 JS，右键保存页面存储到项目中就可以了。 //引入 JS &lt;script src=&quot;js/mui.min.js&quot;&gt;&lt;/script&gt; 联动绑定Mui绝大多数联动，都是采用类似锚点与ID相绑定，选项卡也不例外。 &lt;!-- 例如 --&gt; &lt;a href=&quot;#id-01&quot;&gt;选项卡名称&lt;/a&gt; &lt;div id=&quot;id-01&quot;&gt;选项卡内容&lt;/div&gt; 高亮或选中状态Mui 统一是添加mui-active，所以如果你要默认哪个选项卡先显示，可以在其 class 上添加这个mui-active。 底部选项卡 div 模式&lt;!-- 底部选项卡 --&gt; &lt;nav class=&quot;mui-bar mui-bar-tab&quot;&gt; &lt;a class=&quot;mui-tab-item mui-active&quot; href=&quot;#tabbar&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-home&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;首页&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;mui-tab-item&quot; href=&quot;#tabbar-with-chat&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-email&quot;&gt;&lt;span class=&quot;mui-badge&quot;&gt;9&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;消息&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;mui-tab-item&quot; href=&quot;#tabbar-with-contact&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-contact&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;通讯录&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;mui-tab-item&quot; href=&quot;#tabbar-with-map&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-gear&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;设置&lt;/span&gt; &lt;/a&gt; &lt;/nav&gt; &lt;!-- 选项卡内容 --&gt; &lt;div class=&quot;mui-content&quot;&gt; &lt;div id=&quot;tabbar&quot; class=&quot;mui-control-content mui-active&quot;&gt;tabbar-01&lt;/div&gt; &lt;div id=&quot;tabbar-with-chat&quot; class=&quot;mui-control-content&quot;&gt;tabbar-02&lt;/div&gt; &lt;div id=&quot;tabbar-with-contact&quot; class=&quot;mui-control-content&quot;&gt;tabbar-03&lt;/div&gt; &lt;div id=&quot;tabbar-with-map&quot; class=&quot;mui-control-content&quot;&gt;tabbar-04&lt;/div&gt; &lt;/div&gt; 具体效果如下 顶部选项卡 div 模式添加 DOM 结构 &lt;!-- 选项卡头部 --&gt; &lt;div style=&quot;padding: 10px 10px;&quot;&gt; &lt;div id=&quot;segmentedControl&quot; class=&quot;mui-segmented-control&quot;&gt; &lt;a class=&quot;mui-control-item mui-active&quot; href=&quot;#item1&quot;&gt;选项卡 1&lt;/a&gt; &lt;a class=&quot;mui-control-item&quot; href=&quot;#item2&quot;&gt;选项卡 2&lt;/a&gt; &lt;a class=&quot;mui-control-item&quot; href=&quot;#item3&quot;&gt;选项卡 3&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 选项卡内容 --&gt; &lt;div class=&quot;tabBox&quot;&gt; &lt;div id=&quot;item1&quot; class=&quot;mui-control-content mui-active&quot;&gt;item1&lt;/div&gt; &lt;div id=&quot;item2&quot; class=&quot;mui-control-content&quot;&gt;item2&lt;/div&gt; &lt;div id=&quot;item3&quot; class=&quot;mui-control-content&quot;&gt;item3&lt;/div&gt; &lt;/div&gt; 具体效果如下]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>mui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hbuilder 新增模板]]></title>
    <url>%2F2019%2F05%2F09%2FHbuilder-%E6%96%B0%E5%A2%9E%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[因为用 MUI 框架用的比较多，所以经常官方推荐的的编程工具 HBuilder 。 此教程是针对Mac版的，PC版上有或许有些出入。 打开访达，点击工具栏的前往。 找到资源库，如果没有资源库，请按住 option 键。 在其资源库中找到Applocation Support文件夹。 然后找到 HBuilder X 文件夹，在其文件中找到 templates 文件夹。 如图所示，里面有好几个文件夹代表不同的分类，在该目录新建你常用的模板或将你常用的模板复制到该目录，新建文件时，模板列表会多出以该文件的文件名命名的模板。模板内容为该文件的内容。若不再需要该模板，请删除该文件。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hbuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化CSS]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%88%9D%E5%A7%8B%E5%8C%96CSS%2F</url>
    <content type="text"><![CDATA[初始化 CSS,我觉得这个还蛮重要的，比较浏览器就自带了一些基本样式，但是为了统一性，所以会重置一些 CSS 的基本样式 新浪官网: body,ul,ol,li,p,h1,h2,h3,h4,h5,h6,form,fieldset,table,td,img,div{margin:0;padding:0;border:0;} body{background:#fff;color:#333;font-size:12px; margin-top:5px;font-family:&quot;SimSun&quot;,&quot;宋体&quot;,&quot;Arial Narrow&quot;;} ul,ol{list-style-type:none;} select,input,img,select{vertical-align:middle;} a{text-decoration:none;} a:link{color:#009;} a:visited{color:#800080;} a:hover,a:active,a:focus{color:#c00;text-decoration:underline;} 淘宝官网: body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; } body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; } h1, h2, h3, h4, h5, h6{ font-size:100%; } address, cite, dfn, em, var { font-style:normal; } code, kbd, pre, samp { font-family:couriernew, courier, monospace; } small{ font-size:12px; } ul, ol { list-style:none; } a { text-decoration:none; } a:hover { text-decoration:underline; } sup { vertical-align:text-top; } sub{ vertical-align:text-bottom; } legend { color:#000; } fieldset, img { border:0; } button, input, select, textarea { font-size:100%; } table { border-collapse:collapse; border-spacing:0; } 网易官网: html {overflow-y:scroll;} body {margin:0; padding:29px00; font:12px&quot;\5B8B\4F53&quot;,sans-serif;background:#ffffff;} div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p{padding:0; margin:0;} table,td,tr,th{font-size:12px;} li{list-style-type:none;} img{vertical-align:top;border:0;} ol,ul {list-style:none;} h1,h2,h3,h4,h5,h6{font-size:12px; font-weight:normal;} address,cite,code,em,th {font-weight:normal; font-style:normal;} 腾讯QQ官网: body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select{margin:0;padding:0} body{font:12px&quot;宋体&quot;,&quot;Arial Narrow&quot;,HELVETICA;background:#fff;-webkit-text-size-adjust:100%;} a{color:#2d374b;text-decoration:none} a:hover{color:#cd0200;text-decoration:underline} em{font-style:normal} li{list-style:none} img{border:0;vertical-align:middle} table{border-collapse:collapse;border-spacing:0} p{word-wrap:break-word} 自用: body,html,p,ul,li,h1,h2,h3,h4,h5,h6,input,button{margin:0;padding:0;}]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI AJAX请求]]></title>
    <url>%2F2019%2F05%2F07%2FMUI-AJAX%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[mui框架基于htm5plus的XMLHttpRequest，封装了常用的Ajax函数，支持GET、POST请求方式，支持返回json、xml、html、text、script数据类型； 本着极简的设计原则，mui提供了mui.ajax方法，并在mui.ajax方法基础上，进一步简化出最常用的mui.get()、mui.getJSON()、mui.post()三个方法。 mui.ajax()mui.ajax(&#39;http://server-name/login.php&#39;,{ data:{ username:&#39;username&#39;, password:&#39;password&#39; }, dataType:&#39;json&#39;,//服务器返回json格式数据 type:&#39;post&#39;,//HTTP请求类型 timeout:10000,//超时时间设置为10秒； headers:{&#39;Content-Type&#39;:&#39;application/json&#39;}, success:function(data){ //服务器返回响应，根据响应结果，分析是否登录成功； ... }, error:function(xhr,type,errorThrown){ //异常处理； console.log(type); } }); mui.post()mui.post(&#39;http://server-name/login.php&#39;,{ username:&#39;username&#39;, password:&#39;password&#39; },function(data){ //服务器返回响应，根据响应结果，分析是否登录成功； ... },&#39;json&#39; ); mui.get()mui.get(&#39;http://server-name/list.php&#39;,{category:&#39;news&#39;},function(data){ //获得服务器响应 ... },&#39;json&#39; ); 封装 AJax通常在项目中，我们并不会直接使用它，而是会封装一下。 // **.js 请求数据 function startRequest(url, callBack) { //接口地址 var GETURL = &quot;https://www.easy-mock.com/mock/5cae89ce96ef6f08c01d52de/fitness/&quot; + url; mui.ajax(GETURL, { dataType: &#39;json&#39;, //服务器返回json格式数据 type: &#39;get&#39;, //HTTP请求类型 success: function(data) { console.log(data); callBack(data); //回调函数 }, error: function(xhr, type, errorThrown) { console.log(type); return &quot;网络错误&quot;; } }); } var HTTP_ACTION = { //请求用户名密码 userccount: function(callBack) { startRequest(&quot;userccount&quot;, callBack); } } **.html 调用请求数据 //请求用户名密码 HTTP_ACTION.userccount(function(data){ console.log(data); });]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>mui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass 常用语法]]></title>
    <url>%2F2019%2F05%2F05%2FSass-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以下语法均以 *.scss 为前提。 基本用法变量 SASS允许使用变量，所有变量以$开头 $blue : #1875e7; div { color : $blue; } 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中 $side : left; .rounded { border-#{$side}-radius: 5px; } 计算 SASS允许在代码中使用算式 body { margin: (14px/2); top: 50px + 100px; right: $var * 10%; } 嵌套 SASS允许选择器嵌套 div { hi { color:red; } } 属性嵌套 p { border: { color: red; } } border后面必须加上冒号。 在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成： a { &amp;:hover { color: #ffb3ff; } } 注释SASS共有两种注释风格。 标准的CSS注释 /* comment */，会保留到编译后的文件。 单行注释 // comment，只保留在SASS源文件中，编译后被省略。 在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 /*! 重要注释！*/ 代码的重用继承 SASS允许一个选择器，继承另一个选择器 .class1 { border: 1px solid #ddd; } class2要继承class1，就要使用@extend命令： .class2 { @extend .class1; font-size:120%; } MixinMixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。 @mixin left { float: left; margin-left: 10px; } 使用@include命令，调用这个mixin。 div { @include left; } mixin的强大之处，在于可以指定参数和缺省值。 @mixin left($value: 10px) { float: left; margin-right: $value; } 使用的时候，根据需要加入参数： div { @include left(20px); } 下面是一个mixin的实例，用来生成浏览器前缀。 @mixin rounded($vert, $horz, $radius: 10px) { border-#{$vert}-#{$horz}-radius: $radius; -moz-border-radius-#{$vert}#{$horz}: $radius; -webkit-border-#{$vert}-#{$horz}-radius: $radius; } 使用的时候，可以像下面这样调用： #navbar li { @include rounded(top, left); } #footer { @include rounded(top, left, 5px); } 颜色函数SASS提供了一些内置的颜色函数，以便生成系列颜色。 lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 插入文件@import命令，用来插入外部文件。 @import &quot;path/filename.scss&quot;; 如果插入的是.css文件，则等同于css的import命令。 @import &quot;foo.css&quot;; 高级用法条件语句@if可以用来判断： p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; } } 配套的还有@else命令： @if lightness($color) &gt; 30% { background-color: #000; } @else { background-color: #fff; } 循环语句SASS支持for循环： @for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; } } 也支持while循环： $i: 6; @while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } each命令，作用与for类似： @each $member in a, b, c, d { .#{$member} { background-image: url(&quot;/image/#{$member}.jpg&quot;); } } 自定义函数SASS允许用户编写自己的函数。 @function double($n) { @return $n * 2; } #sidebar { width: double(5px); } 转载-阮一峰老师的SASS教程]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mui.plusReady 初始化]]></title>
    <url>%2F2019%2F04%2F30%2Fmui-plusReady-%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[plus是5+Runtime的内部对象。 就像chrome浏览器里有chrome.开头的一些对象方法，5+runtime内部内置了plus对象。因为plus和mui不一样，plus是引擎级别的，不需要前端框架。而mui是前端框架，所以是要引入mui.js才能使用的。 不要在没有plus和mui的环境下调用相关API. 我们可以初始化一下mui.plusReady方法，代码如下： if(mui.os.plus) { mui.plusReady(ready_fun); } else { mui.ready(ready_fun); } function ready_fun(){ ... 自定义事件 } 我建议事件函数尽可能的写在 ready_fun() 里面，避免不必要的报错。 附上H5+ plus 文档 MUI H5+官方文档]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>mui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass上手指南]]></title>
    <url>%2F2019%2F04%2F29%2FSass%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[创建Sass文件也是新建文件，后缀名改为 .scss或者 .sass ,这两种后缀名都属于 Sass语法，只是两者所使用的语法有些不同。 scss 文件的语法有缩进，用花括号表示层级关系。 /*test.scss*/ #box { width: 160px; height: 200px; background: firebrick; .child { width: 50px; height: 50px; background: #666; border-radius: 50%; } } 编译Sass文件/*在你的文件目录下打开终端*/ scss test.scss 当然这只是在终端编译的，在项目中，我们是需要将显示结果保存成文件，后面再跟一个.css文件名。 /*在你的文件目录下打开终端*/ sass test.scss test.css 然后就会在你的目录下面，多出一个 test.css 和 test.css.map 。在项目中，我们使用的就是编译后的 .css 文件。 scss文件是源文件，网页呈现的是css样式表文件，scss文件通过编译生成css文件，css.map文件是对照表文件。 编译风格Sass有四种编译风格 * nested：嵌套缩进的css代码，它是默认值。 * expanded：没有缩进的、扩展的css代码。 * compact：简洁格式的css代码。 * compressed：压缩后的css代码。 用法 sass --style 编译风格 test.sass test.css 编译后的代码如下 /*nested*/ #box { width: 160px; height: 200px; background: firebrick; } #box .child { width: 50px; height: 50px; background: #666; border-radius: 50%; } /*# sourceMappingURL=test.css.map */ /*expanded*/ #box { width: 160px; height: 200px; background: firebrick; } #box .child { width: 50px; height: 50px; background: #666; border-radius: 50%; } /*# sourceMappingURL=test.css.map */ /*compact*/ #box { width: 160px; height: 200px; background: firebrick; } #box .child { width: 50px; height: 50px; background: #666; border-radius: 50%; } /*# sourceMappingURL=test.css.map */ /*compressed*/ #box{width:160px;height:200px;background:firebrick}#box .child{width:50px;height:50px;background:#666;border-radius:50%} /*# sourceMappingURL=test.css.map */ 平时项目中，采用最后一种方式就可以了。 也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。 // watch a file 监听文件 sass --watch input.scss:output.css // watch a directory 监听目录 sass --watch app/sass:public/stylesheets]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass与SCSS的区别]]></title>
    <url>%2F2019%2F04%2F28%2FSass%E4%B8%8ESCSS%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[最近项目有个需求，需要整体都改大一号字体。心慌慌的全局替换了一下，还好没有出什么其他问题。不过这也引发了我的思考，有没有一种方式，把这些固定的样式写成一种变量，去预编译 CSS。然后我就找到了 Sass。 在学习的过程中，Sass和SCSS傻傻分不清，查阅了诸多的资料，我决定记录一下自己的心得。 Sass是什么？Sass是一种编译为CSS的样式表语言。它允许您使用变量，嵌套规则，混合，函数等，所有这些都使用完全CSS兼容的语法。Sass有助于保持大型样式表的组织良好，并且可以轻松地在项目内和项目间共享设计。 而 Sass 它包含两种语法，一种是 Sass,一种是 SCSS。 Sass 和 SCSS的区别? 后缀名 SCSS 的后缀名是.scss。 Sass 的后缀名是.sass。 语法 SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3。 Sass 的语法没有花括号，并且有严格的缩进，缩进的不同代表层级关系的不同，如果你是 Python 相关人员，用起来会更加容易上手。 SCSS 的语法没有严格的缩进，是用花括号来表示层级关系的，相比 Sass,它更加接近 CSS 的模样。 /*Sass*/ #Sass width: 30% background-color: #faa .childer color:red /*SCSS*/ #sidebar { width: 30%; background-color: #faa; .childer{ color:red; } } 还有一种预编译 CSS语法，stylus, 更加自由个人开发者的话，可以使用。可以自行百度去了解一下。这里不做过多说明了。 参考资料 SCSS 与 Sass 异同 SCSS和Sass有什么区别？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub简单烹饪指南]]></title>
    <url>%2F2019%2F04%2F26%2FGitHub%E7%AE%80%E5%8D%95%E7%83%B9%E9%A5%AA%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[本文简单介绍 GitHub 的日常使用，包括拉取和上传代码。 第一种方式使用客户端。 第二种方法使用命令行操作。 客户端首先新建一个仓库 配置仓库参数 仓库名称： 我建议使用英文名称。 仓库描述：对你这个项目做一个简单的描述。 公开/私有：指你的仓库是否开源。 是否添加自述文件：这个选项选不选随你，现在没有选上的话，建议在后期还是要加上，增加阅读体验。值得注意的是，如果你要导入现有的仓库，那么就不必要添加这个自述文件了，如果做为一个新仓库的使用，还是有很必要添加这个文件的。 你使用的语言：不选的话，它也会自动去识别你所使用的语言。 添加证书：也看你自己的需求吧。 将新建的仓库克隆到本地 新建号的仓库大致如上图所示。点击右边的 Set up in Desktop 下载桌面版 GitHub，下载完成之后，登入你的 GitHub 账号。 选择文件-克隆仓库。 + 第一种方式，选择 GitHub.com 从自己的仓库列表中克隆仓库。 ![GitHub烹饪指南-05](http://images.leegeing.cn/hexoImg/GitHub烹饪指南-05.png) + 第二方式，选择 URL ![GitHub烹饪指南-06](http://images.leegeing.cn/hexoImg/GitHub烹饪指南-06.png) 绿色框表示对应的 URL，橙色框代表克隆至本地的地址。 这两种方式都可以将仓库克隆到自己本地，任选其一即可。 等待克隆结束 稍等片刻就完成了。 我们可以选择第一个打开你刚刚克隆到本地的仓库文件夹。 里面除了一个隐藏的 git文件夹就没有别的东西了。如果我们在创建的时候，勾选上了那个自述文件，那么还会有一个 README.md 文件。 要看到隐藏的文件，需要根据自己的操作系统去开启这个设置，一般默认是关闭的。 以后我们的代码就存放到这个文件夹里面了。 尝试上传到 GitHub 上因为我们没有自述文件，刚好就自己创建一个，上传到 GitHub 当做一次练习。 创建一个名为 README.md 的文件。 前缀 “README” 是 GitHub 自述文件的固定写法，后缀 “.md”，是支持 Markdown 的文本文件。有关于 Markdown 的语法介绍可以自己去百度查一下，有很多有关于这个的介绍。 在 GitHub 客户端上可以看到这个关于这个文件的变动。 在提交处填写你的”提交信息“，然后点击 “commit to master”, 进行提交。然后我们点击”Publish branch“ 发布到当前分支。 等待结束后就完成了上传。我们可以点击”View on GitHub“,打开你的 GitHub 仓库地址，验证是否上传完毕。 如图所示，这是我刚刚上传的自述文件，就已经显示出来了。还有一种方法是使用命令行进行使用 GitHub 的操作，下次有空再说。 ( ^ _ ^ )/~~拜拜]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS使用Sass]]></title>
    <url>%2F2019%2F04%2F25%2FmacOS%E5%AE%89%E8%A3%85Sass%2F</url>
    <content type="text"><![CDATA[Sass 的安装 Sass 是一个 CSS 的扩展，它在 CSS 语法的基础上，允许您使用变量 (variables), 嵌套规则 (nested rules), 混合 (mixins), 导入 (inline imports) 等功能，令 CSS 更加强大与优雅。使用 Sass 以及 Compass 样式库 有助于更好地组织管理样式文件，以及更高效地开发项目。 首先安装 Ruby,因为 Sass 需要有 Ruby 的安装环境。 安装 Ruby 的前提又需要软件包的管理器HomeBrew。 所以我们首先安装 HomeBrew ，在终端输入 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 等待安装结束后。输入 ruby -v ,查看版本号，看是否安装成功。（如下图所示则表示安装成功） 没有出现版本号的话，那就再次安装ruby brew install ruby 出现版本号了则代表安装成功。接下来安装 Sass sudo gem install sass 如果出现安装错误，如下图所示 则输入一下命令重新安装 sudo gem install -n /usr/local/bin sass 安装完成之后，检查 sass 是否安装成功 sass -v 出现版本号了，则代表安装成功 更新sass命令 gem update sass 卸载sass命令 gem uninstall sass Sass在线转换器]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是猿儿郎，不是美工娥]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%88%91%E6%98%AF%E7%8C%BF%E5%84%BF%E9%83%8E%EF%BC%8C%E4%B8%8D%E6%98%AF%E7%BE%8E%E5%B7%A5%E5%A8%A5%2F</url>
    <content type="text"><![CDATA[不想当切图仔，不想当美工啊，我想要当全栈 算了算工作的年头，我快工作两年了，但感觉自己远远没有两年应该有的工作经验。平日里的项目切完静态页面，丢给后台就行了，剩下的事情不用我操心。这样的工作是比较简单，但是这也造就了我在技术上的止步。 从今年的项目开始，我便有意无意的介入后端，前端静态页面切完后，我会找后台要接口，我开始尝试自己学习数据的请求，页面的动态渲染，虽然这都很简单，但是我慢慢找到了熟悉的感觉。我开始有了目标，不再仿徨。 每天都会过的很充实，我像一块海绵，大口贪婪的吸收新知识。以前我不懂的，我不理解的东西，现在回过头来看，发现也不是那么难，一切都是有迹可循的。 公司里一直被人当美工，我是不愿意的，并不是说美工不好，也不是我对美工有歧视，我只是更加想当一名程序猿。我也不愿意当个切图仔，这不是我想要的，我想当一名 web 前端程序猿。我想出去看看这个世界，不想一直都这样得过且过。我是猿儿郎，不是美工娥。 前端入门很简单，但是想要精通，还有很长一段路要走，在这个技术日新月异的时代，必须不断学习，不断进步，才能跟上时代的步伐，不被时代所淘汰。 加油呀~]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue路由传参]]></title>
    <url>%2F2019%2F04%2F23%2FVue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[Vue页面路由实现页面之间的跳转，我们还可以通过路由来进行参数之间的传递 第一种方式是通过 query 传参 //index.vue &lt;router-link :to=&quot;{ path: &#39;your router url&#39;, query: { name: &#39;your parameters&#39; } }&quot;&gt;link name&lt;/router-link&gt; //your link &lt;div&gt;get parameters: {{ this.$route.query.name }}&lt;/div&gt; 第二种方式是通过 params 来传参 //index.vue &lt;router-link :to=&quot;{ path: &#39;your router url&#39;, params: { name: &#39;your parameters&#39; } }&quot;&gt;link name&lt;/router-link&gt; //your link &lt;div&gt;get parameters: {{ this.$route.params.name }}&lt;/div&gt; 第三种方式通过 router/index.js 中的 name 属性去传参 // router/index.js { path: &#39;your router url&#39;, name: &#39;😊your parameters&#39;, component: routerName } //your link &lt;div&gt;get parameters: {{ this.$route.name }}&lt;/div&gt; 具体效果如下： query 传参和 params 来传参的区别： params: params只能用name来引入路由，如果这里写成了path，接收参数页面会是undefined。 query: 相当于get请求，这种传参方式相当于url拼接参数，页面跳转的时候，可以在地址栏看到请求参数。 params: 相当于post请求，参数可以传递但是地址栏不会显示，刷新时会造成参数丢失。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 简单路由]]></title>
    <url>%2F2019%2F04%2F22%2FVue%E7%AE%80%E5%8D%95%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[附上demo 地址：Vue简单路由 demo 项目中引入 vue-router npm install vue-router 新建一个 *.js 文件 初始化路由模块 //router.js import Vue from &#39;vue&#39; import VueRouter from &#39;vue-router&#39; Vue.use(VueRouter) 新建一个文件夹，名字随意，创建两个子 *.vue文件，并把它们初始化。 如图所示蓝色框内的是子路由，绿色框内的是平级路由。 在router.js 中设置路由配置 import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; //引入*.vue 页面 import Index from &#39;@/components/index.vue&#39; import Hi1 from &#39;@/components/children/hi1.vue&#39; import Hi2 from &#39;@/components/children/hi2.vue&#39; import Clicli from &#39;@/components/clicli.vue&#39; Vue.use(Router) export default new Router({ routes: [{ path: &#39;/&#39;, //重定向路由 name: &#39;Index&#39;, component: Index, children: [ //配置子路由 { path: &#39;/&#39;, component: Hi2 }, { path: &#39;/index/hi1&#39;, component: Hi1 }, { path: &#39;/index/hi2&#39;, component: Hi2 } ] }, { //同级路由 path: &#39;/clicli&#39;, name: &#39;Clicli&#39;, component: Clicli }, { path: &#39;/hi1&#39;, name: &#39;Hi1&#39;, component: Hi1 }] }) 在 index.vue 中配置子路由的入口端 &lt;template&gt; &lt;div&gt; &lt;ol start=&quot;1&quot; class=&quot;index-list&quot;&gt; &lt;li&gt;&lt;router-link to=&quot;/index/hi1&quot;&gt;子路由 H1&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/index/hi2&quot;&gt;子路由 H2&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/clicli&quot;&gt;(全屏) 平级路由 CliCli&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/hi1&quot;&gt;(全屏) 子路由 H1&lt;/router-link&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class=&quot;routerBox&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; &lt;style&gt; li{ list-style: none; } .index-list{ margin: 0; padding: 10px; text-align: left; } .index-list&gt;li{ line-height: 30px; } .routerBox{ margin: 10px; padding: 10px; border: 1px solid #000; } &lt;/style&gt; 具体实现效果如下 vue路由 mode属性 hash 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载。(有#号) history 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 当你使用 history 模式时，URL 就像正常的 url一样。(无#号)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac-文件夹内快捷打开命令行]]></title>
    <url>%2F2019%2F04%2F19%2FMac-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E5%BF%AB%E6%8D%B7%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[macOS 的终端很好用，但是却不能像 Windows 那么便捷的文件夹内打开终端，只能手动 cd 定位到当前目录。 附上大佬的 GitHub 地址：OpenInTerminal 地址 打开下载地址，下载最新的文件 解压后得到一个 OpenInTerminal应用 和一个 iocn 文件夹，把OpenInTerminal应用拖进应用程序进行安装。 最后选择默认的终端就可以啦。 最后的效果就是如下图所示，在文件内点开就可以直接打开终端了。 重选选择默认终端，请在终端执行如下命令： defaults remove wang.jianing.OpenInTerminal OIT_TerminalBundleIdentifier]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>OpenInTerminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI跨页面调用方法]]></title>
    <url>%2F2019%2F04%2F17%2FMUI%E8%B7%A8%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[因为公司项目用 MUI 用得比较多，有碰到如下需求： 在一个双 WebView 的上拉刷新下拉加载的页面中，A页面就是父页面，B页面就是列表页。A页面中还带有搜索框，搜索框中的值会被传到 B页面，进行数据请求。 //A页面 function setTotal(parameters){ …… } //B页面 var total = 需要传的参数; var evalstr = &#39;setTotal(\&#39;&#39; + total + &#39;\&#39;)&#39;; var wvs = plus.webview.all(); for (var i = 0; i &lt; wvs.length; i++) { console.log(&#39;webview&#39; + i + &#39;: &#39; + wvs[i].id); if(wvs[i].id==&quot;你的 WebView ID&quot;){ wvs[i].evalJS(evalstr); } }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>mui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的DOS命令]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%B8%B8%E7%94%A8%E7%9A%84DOS-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[DOS命令：计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。 目前大家常用的操作系统有windows10,windows 7等，都是图形化的界面。在有这些系统之前的人们使用的操作系统是DOS系统。 macOS命令行的使用不全包括以下命令。 回看上一次执行的命令 向上箭头&quot;↑&quot;和向下箭头&quot;↓&quot; 中断操作 &quot;Ctrl+C&quot; 组合键或&quot;Break&quot;键 盘符: 直接进入某盘符 如直接进入D盘，D： md 建立子目录 md[盘符：][路径名]〈子目录名〉 md c:\ fox （在当前驱动器c盘下创建子目录fox） cd 改变当前目录 cd [/D] [drive:][path] (进入某一目录) cd ../ (返回上级目录) 查看当前目录下的文件和子目录列表 dir 命令行清屏 cls]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 简便替换空值]]></title>
    <url>%2F2019%2F04%2F17%2FJS%E7%AE%80%E4%BE%BF%E6%9B%BF%E6%8D%A2%E7%A9%BA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在与后台对接的时候，经常有时候会拿到一个空值 undefined，把 undefined 显示在页面上，对于普通用户来说，是不可行的。以下有一中简便的方便，快速替换 undefined。 这行代码的意思就是：如果值为false，那么就采用后面的，如果值为true，那么就采用前面的。 var myEntryStandard = ParentDelivery[i].EntryStandard||&quot;无&quot;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加全局搜索]]></title>
    <url>%2F2019%2F04%2F16%2FHexo%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[安装搜索插件hexo-generator-searchdbnpm install hexo-generator-searchdb --save 找到到博客配置文件 _config.yml，添加如下配置search: path: search.xml field: post format: html limit: 10000 Next 主题自带搜索设置，编辑主题配置文件：_config.yml找到文件中 Local search 的相关配置，设为 true # Local search local_search: enable: true 重新部署 hexo$ hexo clean $ hexo g $ hexo d]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS格式化时间戳]]></title>
    <url>%2F2019%2F04%2F16%2FJS%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E6%88%B3%2F</url>
    <content type="text"><![CDATA[在项目中经常会遇到后台接口返回来的时间戳，我们需要转换一下才能显示日常使用的时间格式。 //转换时间格式 function getNowFormatDate(setdate) { var date = new Date(setdate); var seperator1 = &quot;-&quot;; var seperator2 = &quot;:&quot;; var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) { month = &quot;0&quot; + month; } if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) { strDate = &quot;0&quot; + strDate; } var h = date.getHours(); var m = date.getMinutes(); var s = date.getSeconds(); if (h &gt;= 0 &amp;&amp; h &lt;= 9) { h = &quot;0&quot; + h; } if (m &gt;= 0 &amp;&amp; m &lt;= 9) { m = &quot;0&quot; + m; } if (s &gt;= 0 &amp;&amp; s &lt;= 9) { s = &quot;0&quot; + s; } var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate + &quot; &quot; + h + seperator2 + m; return currentdate; }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI子页面向父页面传参]]></title>
    <url>%2F2019%2F04%2F15%2FMUI%E5%AD%90%E9%A1%B5%E9%9D%A2%E5%90%91%E7%88%B6%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[经常有这样的需求：子页面新增数据后完成后，跳转到父页面的列表界面。但是 MUI 采用的是页面跳转其实是打开新窗口，返回父页面并不会刷新父页面，只是把子页面关闭，父页面从始至终都在那里并没有刷新过。 思路：子页面提交数据后，向父页面传参，父页面监听子页面的参数，调用刷新方法，从而达到页面刷新，数据更新的目的。 子页面： //向父页面传参 mui.fire (plus.webview.currentWebview().opener(), &#39;getRes&#39;, { &quot;type&quot;: 1 }); mui.back(); 其中 res 是上传数据，后台接口返回的参数，用于判断是否成功，成功的话，向父页面传参，并调用 mui.bac() 方法关闭页面。getRes 是监听的方法，父页面监听子页面的数据变化，需要用到这个监听方法，命名可以自取。 父页面： //监听子页面提交数据后，刷新页面 window.addEventListener(&#39;getRes&#39;, function(event) { //获得事件参数 var type = event.detail.type; if (type == 1) { location.reload(); } });]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>mui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI父页面向子页面传参]]></title>
    <url>%2F2019%2F04%2F14%2FMUI%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%90%91%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[在以往有讲过MUI 创建新页面 ，其中有提到 extras 传参。 我们可以在 a 标签中进行页面的跳转和传参，但是如果数据量较多的话，会影响代码的可读性，我建议还是写在 JS 中。 这里有一个很简单的例子,可以参考一下方法进行页面之间的传参。openUrl 的方法可以参考创建页面的那个方法。 父页面： //父页面传值 $(&quot;#id&quot;).on(&quot;.child&quot;,&quot;tap&quot;,function(){ var id = $(this).attr(&quot;parameterID&quot;); openUrl(&#39;url&#39;,&#39;id&#39;,{&#39;parameter&#39;:parameterID}); }); parameter是子页面接收参数的名字 子页面： // 接收父页面传值 var self = plus.webview.currentWebview(); console.log(self.parameter); var parameterID = self.parameter; MUI 提供了很多父页面向子页面传参的方法，不过我个人用得比较多的是这一种方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>mui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI创建新页面]]></title>
    <url>%2F2019%2F04%2F13%2FMUI%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[在常规的前端开发中,我们经常使用a标签中的href属性来进行页面之间的跳转和传参. 但是这样会产生一个问题,a标签打开的页面返回时并不是返回到上一个页面,返回只是一个后退的操作. 如果对页面进行多次操作页面,当你想回到上一个页面时,就会来回的切换页面,严重影响体验. 在一个项目中,我们可以写一个公共的JS文件,创建新页面方法,代码如下. //创建新页面 function openUrl(url, id, params) { if (typeof(params) == &#39;undefined&#39;) { params = {}; } if (mui.os.plus) { mui.openWindow({ id: id, //url:新页面的地址 url: url, //id:新页面的 WebView ID extras: params, //params:页面传参 styles: { statusbar: { //设置新页面状态栏背景颜色，以便达到沉浸式状态栏 background: &#39;#3EAD74&#39;, color: &#39;#FFFFFF&#39; } } }) } else { window.location.href = url; } } 引用 js 文件后就可以,我们可以用a标签进行快速的使用. &lt;a href=&quot;javascript:openUrl(&#39;url&#39;,&#39;id&#39;,{})&quot;&gt;打开新的 webview页面&lt;/a&gt; 我们可以很方便的用 a 标签进行传参，但是要注意的是，在动态生成的 DOM 结构里，用 a 标签来传参的话，页面跳转会失效。我的建议是用JS点击绑定事件进行页面的跳转和传参。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>mui</tag>
      </tags>
  </entry>
</search>
