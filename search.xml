<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mui.plusReady 初始化]]></title>
    <url>%2F2019%2F04%2F30%2Fmui-plusReady-%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[plus是5+Runtime的内部对象。就像chrome浏览器里有chrome.开头的一些对象方法，5+runtime内部内置了plus对象。因为plus和mui不一样，plus是引擎级别的，不需要前端框架。而mui是前端框架，所以是要引入mui.js才能使用的。 不要在没有plus和mui的环境下调用相关API. 我们可以初始化一下mui.plusReady方法，代码如下： 123456789if(mui.os.plus) &#123; mui.plusReady(ready_fun);&#125; else &#123; mui.ready(ready_fun);&#125; function ready_fun()&#123; ... 自定义事件&#125; 我建议事件函数尽可能的写在 ready_fun() 里面，避免不必要的报错。 附上H5+ plus 文档 MUI H5+官方文档]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass上手指南]]></title>
    <url>%2F2019%2F04%2F29%2FSass%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[创建Sass文件也是新建文件，后缀名改为 .scss或者 .sass ,这两种后缀名都属于 Sass语法，只是两者所使用的语法有些不同。 scss 文件的语法有缩进，用花括号表示层级关系。 123456789101112/*test.scss*/#box &#123; width: 160px; height: 200px; background: firebrick; .child &#123; width: 50px; height: 50px; background: #666; border-radius: 50%; &#125;&#125; 编译Sass文件12/*在你的文件目录下打开终端*/scss test.scss 当然这只是在终端编译的，在项目中，我们是需要将显示结果保存成文件，后面再跟一个.css文件名。 12/*在你的文件目录下打开终端*/sass test.scss test.css 然后就会在你的目录下面，多出一个 test.css 和 test.css.map 。在项目中，我们使用的就是编译后的 .css 文件。 scss文件是源文件，网页呈现的是css样式表文件，scss文件通过编译生成css文件，css.map文件是对照表文件。 编译风格Sass有四种编译风格 1234567* nested：嵌套缩进的css代码，它是默认值。 * expanded：没有缩进的、扩展的css代码。 * compact：简洁格式的css代码。 * compressed：压缩后的css代码。 用法 1sass --style 编译风格 test.sass test.css 编译后的代码如下 123456789101112/*nested*/#box &#123; width: 160px; height: 200px; background: firebrick; &#125; #box .child &#123; width: 50px; height: 50px; background: #666; border-radius: 50%; &#125;/*# sourceMappingURL=test.css.map */ 1234567891011121314/*expanded*/#box &#123; width: 160px; height: 200px; background: firebrick;&#125;#box .child &#123; width: 50px; height: 50px; background: #666; border-radius: 50%;&#125;/*# sourceMappingURL=test.css.map */ 12345/*compact*/#box &#123; width: 160px; height: 200px; background: firebrick; &#125;#box .child &#123; width: 50px; height: 50px; background: #666; border-radius: 50%; &#125;/*# sourceMappingURL=test.css.map */ 123/*compressed*/#box&#123;width:160px;height:200px;background:firebrick&#125;#box .child&#123;width:50px;height:50px;background:#666;border-radius:50%&#125;/*# sourceMappingURL=test.css.map */ 平时项目中，采用最后一种方式就可以了。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass与SCSS的区别]]></title>
    <url>%2F2019%2F04%2F28%2FSass%E4%B8%8ESCSS%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[最近项目有个需求，需要整体都改大一号字体。心慌慌的全局替换了一下，还好没有出什么其他问题。不过这也引发了我的思考，有没有一种方式，把这些固定的样式写成一种变量，去预编译 CSS。然后我就找到了 Sass。 在学习的过程中，Sass和SCSS傻傻分不清，查阅了诸多的资料，我决定记录一下自己的心得。 Sass是什么？Sass是一种编译为CSS的样式表语言。它允许您使用变量，嵌套规则，混合，函数等，所有这些都使用完全CSS兼容的语法。Sass有助于保持大型样式表的组织良好，并且可以轻松地在项目内和项目间共享设计。 而 Sass 它包含两种语法，一种是 Sass,一种是 SCSS。 Sass 和 SCSS的区别? 后缀名 SCSS 的后缀名是.scss。 Sass 的后缀名是.sass。 语法 SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3。 Sass 的语法没有花括号，并且有严格的缩进，缩进的不同代表层级关系的不同，如果你是 Python 相关人员，用起来会更加容易上手。 SCSS 的语法没有严格的缩进，是用花括号来表示层级关系的，相比 Sass,它更加接近 CSS 的模样。 123456789101112131415/*Sass*/#Sass width: 30% background-color: #faa .childer color:red /*SCSS*/#sidebar &#123; width: 30%; background-color: #faa; .childer&#123; color:red; &#125;&#125; 还有一种预编译 CSS语法，stylus, 更加自由个人开发者的话，可以使用。可以自行百度去了解一下。这里不做过多说明了。 参考资料 SCSS 与 Sass 异同 SCSS和Sass有什么区别？]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub简单烹饪指南]]></title>
    <url>%2F2019%2F04%2F26%2FGitHub%E7%AE%80%E5%8D%95%E7%83%B9%E9%A5%AA%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[本文简单介绍 GitHub 的日常使用，包括拉取和上传代码。 第一种方式使用客户端。 第二种方法使用命令行操作。 客户端首先新建一个仓库 配置仓库参数 仓库名称： 我建议使用英文名称。 仓库描述：对你这个项目做一个简单的描述。 公开/私有：指你的仓库是否开源。 是否添加自述文件：这个选项选不选随你，现在没有选上的话，建议在后期还是要加上，增加阅读体验。值得注意的是，如果你要导入现有的仓库，那么就不必要添加这个自述文件了，如果做为一个新仓库的使用，还是有很必要添加这个文件的。 你使用的语言：不选的话，它也会自动去识别你所使用的语言。 添加证书：也看你自己的需求吧。 将新建的仓库克隆到本地 新建号的仓库大致如上图所示。点击右边的 Set up in Desktop 下载桌面版 GitHub，下载完成之后，登入你的 GitHub 账号。 选择文件-克隆仓库。 + 第一种方式，选择 GitHub.com 从自己的仓库列表中克隆仓库。 ![GitHub烹饪指南-05](http://images.leegeing.cn/hexoImg/GitHub烹饪指南-05.png) + 第二方式，选择 URL ![GitHub烹饪指南-06](http://images.leegeing.cn/hexoImg/GitHub烹饪指南-06.png) 绿色框表示对应的 URL，橙色框代表克隆至本地的地址。 这两种方式都可以将仓库克隆到自己本地，任选其一即可。 等待克隆结束 稍等片刻就完成了。 我们可以选择第一个打开你刚刚克隆到本地的仓库文件夹。 里面除了一个隐藏的 git文件夹就没有别的东西了。如果我们在创建的时候，勾选上了那个自述文件，那么还会有一个 README.md 文件。 要看到隐藏的文件，需要根据自己的操作系统去开启这个设置，一般默认是关闭的。 以后我们的代码就存放到这个文件夹里面了。 尝试上传到 GitHub 上因为我们没有自述文件，刚好就自己创建一个，上传到 GitHub 当做一次练习。 创建一个名为 README.md 的文件。 前缀 “README” 是 GitHub 自述文件的固定写法，后缀 “.md”，是支持 Markdown 的文本文件。有关于 Markdown 的语法介绍可以自己去百度查一下，有很多有关于这个的介绍。 在 GitHub 客户端上可以看到这个关于这个文件的变动。 在提交处填写你的”提交信息“，然后点击 “commit to master”, 进行提交。然后我们点击”Publish branch“ 发布到当前分支。 等待结束后就完成了上传。我们可以点击”View on GitHub“,打开你的 GitHub 仓库地址，验证是否上传完毕。 如图所示，这是我刚刚上传的自述文件，就已经显示出来了。还有一种方法是使用命令行进行使用 GitHub 的操作，下次有空再说。 ( ^ _ ^ )/~~拜拜]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS使用Sass]]></title>
    <url>%2F2019%2F04%2F25%2FmacOS%E5%AE%89%E8%A3%85Sass%2F</url>
    <content type="text"><![CDATA[Sass 是一个 CSS 的扩展，它在 CSS 语法的基础上，允许您使用变量 (variables), 嵌套规则 (nested rules), 混合 (mixins), 导入 (inline imports) 等功能，令 CSS 更加强大与优雅。使用 Sass 以及 Compass 样式库 有助于更好地组织管理样式文件，以及更高效地开发项目。 首先安装 Ruby,因为 Sass 需要有 Ruby 的安装环境。 安装 Ruby 的前提又需要软件包的管理器HomeBrew。 所以我们首先安装 HomeBrew ，在终端输入 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 等待安装结束后。输入 ruby -v ,查看版本号，看是否安装成功。（如下图所示则表示安装成功） 没有出现版本号的话，那就再次安装ruby 1brew install ruby 出现版本号了则代表安装成功。接下来安装 Sass 1sudo gem install sass 如果出现安装错误，如下图所示 则输入一下命令重新安装 1sudo gem install -n /usr/local/bin sass 安装完成之后，检查 sass 是否安装成功 1sass -v 出现版本号了，则代表安装成功 更新sass命令 1gem update sass 卸载sass命令 1gem uninstall sass Sass在线转换器]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是猿儿郎，不是美工娥]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%88%91%E6%98%AF%E7%8C%BF%E5%84%BF%E9%83%8E%EF%BC%8C%E4%B8%8D%E6%98%AF%E7%BE%8E%E5%B7%A5%E5%A8%A5%2F</url>
    <content type="text"><![CDATA[算了算工作的年头，我快工作两年了，但感觉自己远远没有两年应该有的工作经验。平日里的项目切完静态页面，丢给后台就行了，剩下的事情不用我操心。这样的工作是比较简单，但是这也造就了我在技术上的止步。 从今年的项目开始，我便有意无意的介入后端，前端静态页面切完后，我会找后台要接口，我开始尝试自己学习数据的请求，页面的动态渲染，虽然这都很简单，但是我慢慢找到了熟悉的感觉。我开始有了目标，不再仿徨。 每天都会过的很充实，我像一块海绵，大口贪婪的吸收新知识。以前我不懂的，我不理解的东西，现在回过头来看，发现也不是那么难，一切都是有迹可循的。 公司里一直被人当美工，我是不愿意的，并不是说美工不好，也不是我对美工有歧视，我只是更加想当一名程序猿。我也不愿意当个切图仔，这不是我想要的，我想当一名 web 前端程序猿。我想出去看看这个世界，不想一直都这样得过且过。我是猿儿郎，不是美工娥 前端入门很简单，但是想要精通，还有很长一段路要走，在这个技术日新月异的时代，必须不断学习，不断进步，才能跟上时代的步伐，不被时代所淘汰。 加油呀~]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>小秘密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue路由传参]]></title>
    <url>%2F2019%2F04%2F23%2FVue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[Vue页面路由实现页面之间的跳转，我们还可以通过路由来进行参数之间的传递 第一种方式是通过 query 传参 12//index.vue&lt;router-link :to=&quot;&#123; path: &apos;your router url&apos;, query: &#123; name: &apos;your parameters&apos; &#125; &#125;&quot;&gt;link name&lt;/router-link&gt; 12//your link&lt;div&gt;get parameters: &#123;&#123; this.$route.query.name &#125;&#125;&lt;/div&gt; 第二种方式是通过 params 来传参 12//index.vue&lt;router-link :to=&quot;&#123; path: &apos;your router url&apos;, params: &#123; name: &apos;your parameters&apos; &#125; &#125;&quot;&gt;link name&lt;/router-link&gt; 12//your link&lt;div&gt;get parameters: &#123;&#123; this.$route.params.name &#125;&#125;&lt;/div&gt; 第三种方式通过 router/index.js 中的 name 属性去传参 123456// router/index.js &#123; path: &apos;your router url&apos;, name: &apos;😊your parameters&apos;, component: routerName&#125; 12//your link&lt;div&gt;get parameters: &#123;&#123; this.$route.name &#125;&#125;&lt;/div&gt; 具体效果如下： query 传参和 params 来传参的区别： params: params只能用name来引入路由，如果这里写成了path，接收参数页面会是undefined。 query: 相当于get请求，这种传参方式相当于url拼接参数，页面跳转的时候，可以在地址栏看到请求参数。 params: 相当于post请求，参数可以传递但是地址栏不会显示，刷新时会造成参数丢失。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 简单路由]]></title>
    <url>%2F2019%2F04%2F22%2FVue%E7%AE%80%E5%8D%95%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[附上demo 地址：Vue简单路由 demo 项目中引入 vue-router 1npm install vue-router 新建一个 *.js 文件 初始化路由模块 12345//router.jsimport Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;Vue.use(VueRouter) 新建一个文件夹，名字随意，创建两个子 *.vue文件，并把它们初始化。 如图所示蓝色框内的是子路由，绿色框内的是平级路由。 在router.js 中设置路由配置 12345678910111213141516171819202122232425262728293031323334353637383940import Vue from &apos;vue&apos; import Router from &apos;vue-router&apos;//引入*.vue 页面import Index from &apos;@/components/index.vue&apos; import Hi1 from &apos;@/components/children/hi1.vue&apos; import Hi2 from &apos;@/components/children/hi2.vue&apos; import Clicli from &apos;@/components/clicli.vue&apos;Vue.use(Router)export default new Router(&#123; routes: [&#123; path: &apos;/&apos;, //重定向路由 name: &apos;Index&apos;, component: Index, children: [ //配置子路由 &#123; path: &apos;/&apos;, component: Hi2 &#125;, &#123; path: &apos;/index/hi1&apos;, component: Hi1 &#125;, &#123; path: &apos;/index/hi2&apos;, component: Hi2 &#125; ] &#125;, &#123; //同级路由 path: &apos;/clicli&apos;, name: &apos;Clicli&apos;, component: Clicli &#125;, &#123; path: &apos;/hi1&apos;, name: &apos;Hi1&apos;, component: Hi1 &#125;]&#125;) 在 index.vue 中配置子路由的入口端 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;ol start=&quot;1&quot; class=&quot;index-list&quot;&gt; &lt;li&gt;&lt;router-link to=&quot;/index/hi1&quot;&gt;子路由 H1&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/index/hi2&quot;&gt;子路由 H2&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/clicli&quot;&gt;(全屏) 平级路由 CliCli&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/hi1&quot;&gt;(全屏) 子路由 H1&lt;/router-link&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class=&quot;routerBox&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt; li&#123; list-style: none; &#125; .index-list&#123; margin: 0; padding: 10px; text-align: left; &#125; .index-list&gt;li&#123; line-height: 30px; &#125; .routerBox&#123; margin: 10px; padding: 10px; border: 1px solid #000; &#125;&lt;/style&gt; 具体实现效果如下 vue路由 mode属性 hash 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载。(有#号) history 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 当你使用 history 模式时，URL 就像正常的 url一样。(无#号)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预设图片比例]]></title>
    <url>%2F2019%2F04%2F21%2F%E9%A2%84%E8%AE%BE%E5%9B%BE%E7%89%87%E6%AF%94%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[在项目中，经常有用到图片，但是我们不能直接使用图片，防止图片大小不一致，而导致页面的布局错乱，但是又不能直接把图片的宽高写成固定的，不然图片会变形之类的。所以我们我们需要一个等比例的图片宽高，又不能使图片变形。我推荐采用以下这种方式。 1234// html &lt;div class=&quot;demoImg&quot;&gt; &lt;img src=&quot;http://images.leegeing.cn/hexoImg/demo.jpeg&quot;&gt; &lt;/div&gt; 12345678910111213141516// css.demoImg&#123; position: relative; width: 100%; height: 0; padding-top: 100%; overflow: hidden;&#125;.demoImg&gt;img&#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#125; 当 CSS 的宽度 width 和上内边距 padding-top 的都为 100%，代表的是 1:1 的图片比例。 当设置为宽高和上内边距的分别设置为 100%，和 75%的时候，代表的图片比例 4：3 的比例。 object-fit 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。 fill被替换的内容正好填充元素的内容框。整个对象将完全填充此框。如果对象的宽高比与内容框不相匹配，那么该对象将被拉伸以适应内容框。 contain被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“黑边”。 cover被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。 none被替换的内容将保持其原有的尺寸。 scale-down内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 浏览器的兼容性]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS字体溢出隐藏]]></title>
    <url>%2F2019%2F04%2F20%2FCSS%E5%AD%97%E4%BD%93%E6%BA%A2%E5%87%BA%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[单行字体溢出隐藏 123text-overflow:ellipsis;white-space: nowrap;overflow: hidden; 多行字体溢出隐藏 1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac-文件夹内快捷打开命令行]]></title>
    <url>%2F2019%2F04%2F19%2FMac-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E5%BF%AB%E6%8D%B7%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[macOS 的终端很好用，但是却不能像 Windows 那么便捷的文件夹内打开终端，只能手动 cd 定位到当前目录。 附上大佬的 GitHub 地址：OpenInTerminal 地址 打开下载地址，下载最新的文件 解压后得到一个 OpenInTerminal应用 和一个 iocn 文件夹，把OpenInTerminal应用拖进应用程序进行安装。 最后选择默认的终端就可以啦。 最后的效果就是如下图所示，在文件内点开就可以直接打开终端了。 重选选择默认终端，请在终端执行如下命令： 1defaults remove wang.jianing.OpenInTerminal OIT_TerminalBundleIdentifier]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI跨页面调用方法]]></title>
    <url>%2F2019%2F04%2F17%2FMUI%E8%B7%A8%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[因为公司项目用 MUI 用得比较多，有碰到如下需求： 在一个双 WebView 的上拉刷新下拉加载的页面中，A页面就是父页面，B页面就是列表页。A页面中还带有搜索框，搜索框中的值会被传到 B页面，进行数据请求。 1234//A页面function setTotal(parameters)&#123; ……&#125; 1234567891011//B页面var total = 需要传的参数;var evalstr = &apos;setTotal(\&apos;&apos; + total + &apos;\&apos;)&apos;;var wvs = plus.webview.all();for (var i = 0; i &lt; wvs.length; i++) &#123; console.log(&apos;webview&apos; + i + &apos;: &apos; + wvs[i].id); if(wvs[i].id==&quot;你的 WebView ID&quot;)&#123; wvs[i].evalJS(evalstr); &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo更换博客主题]]></title>
    <url>%2F2019%2F04%2F17%2FHexo%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Hexo 有很多主题可以选择，但是我试过好几种，还是喜欢 nexT 主题，集成了很多插件，用起来很方便。 安装 nexT 主题有多种方式，大同小异。我不过我使用的是 git clone 的方法。 首先克隆 nexT 的仓库到我们的博客中。 12cd 你的博客目录git clone https://github.com/iissnan/hexo-theme-next themes/next 编辑 博客配置文件 _config.yml 1theme: next NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 以防万一，我们先在本地预览博客是否成功更换了主题，启动本地服务预览一下。 1hexo s 如果成功了的话，那么就可以把博客重新部署到服务器上了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的DOS命令]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%B8%B8%E7%94%A8%E7%9A%84DOS-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[DOS命令：计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。 目前大家常用的操作系统有windows10,windows 7等，都是图形化的界面。在有这些系统之前的人们使用的操作系统是DOS系统。 macOS命令行的使用不全包括以下命令。 回看上一次执行的命令 1向上箭头&quot;↑&quot;和向下箭头&quot;↓&quot; 中断操作 1&quot;Ctrl+C&quot; 组合键或&quot;Break&quot;键 盘符: 直接进入某盘符 1如直接进入D盘，D： md 建立子目录 12md[盘符：][路径名]〈子目录名〉md c:\ fox （在当前驱动器c盘下创建子目录fox） cd 改变当前目录 12cd [/D] [drive:][path] (进入某一目录)cd ../ (返回上级目录) 查看当前目录下的文件和子目录列表 1dir 命令行清屏 1cls]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 简便替换空值]]></title>
    <url>%2F2019%2F04%2F17%2FJS%E7%AE%80%E4%BE%BF%E6%9B%BF%E6%8D%A2%E7%A9%BA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在与后台对接的时候，经常有时候会拿到一个空值 undefined，把 undefined 显示在页面上，对于普通用户来说，是不可行的。以下有一中简便的方便，快速替换 undefined。 这行代码的意思就是：如果值为false，那么就采用后面的，如果值为true，那么就采用前面的。1var myEntryStandard = ParentDelivery[i].EntryStandard||&quot;无&quot;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加全局搜索]]></title>
    <url>%2F2019%2F04%2F16%2FHexo%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[安装搜索插件hexo-generator-searchdb1npm install hexo-generator-searchdb --save 找到到博客配置文件 _config.yml，添加如下配置12345search: path: search.xml field: post format: html limit: 10000 Next 主题自带搜索设置，编辑主题配置文件：_config.yml找到文件中 Local search 的相关配置，设为 true 123# Local searchlocal_search: enable: true 重新部署 hexo123$ hexo clean$ hexo g$ hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS格式化时间戳]]></title>
    <url>%2F2019%2F04%2F16%2FJS%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E6%88%B3%2F</url>
    <content type="text"><![CDATA[在项目中经常会遇到后台接口返回来的时间戳，我们需要转换一下才能显示日常使用的时间格式。 1234567891011121314151617181920212223242526272829303132//转换时间格式function getNowFormatDate(setdate) &#123; var date = new Date(setdate); var seperator1 = &quot;-&quot;; var seperator2 = &quot;:&quot;; var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = &quot;0&quot; + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = &quot;0&quot; + strDate; &#125; var h = date.getHours(); var m = date.getMinutes(); var s = date.getSeconds(); if (h &gt;= 0 &amp;&amp; h &lt;= 9) &#123; h = &quot;0&quot; + h; &#125; if (m &gt;= 0 &amp;&amp; m &lt;= 9) &#123; m = &quot;0&quot; + m; &#125; if (s &gt;= 0 &amp;&amp; s &lt;= 9) &#123; s = &quot;0&quot; + s; &#125; var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate + &quot; &quot; + h + seperator2 + m; return currentdate;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI子页面向父页面传参]]></title>
    <url>%2F2019%2F04%2F15%2FMUI%E5%AD%90%E9%A1%B5%E9%9D%A2%E5%90%91%E7%88%B6%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[经常有这样的需求：子页面新增数据后完成后，跳转到父页面的列表界面。但是 MUI 采用的是页面跳转其实是打开新窗口，返回父页面并不会刷新父页面，只是把子页面关闭，父页面从始至终都在那里并没有刷新过。 思路：子页面提交数据后，向父页面传参，父页面监听子页面的参数，调用刷新方法，从而达到页面刷新，数据更新的目的。 子页面： 12345//向父页面传参mui.fire (plus.webview.currentWebview().opener(), &apos;getRes&apos;, &#123; &quot;type&quot;: 1&#125;);mui.back(); 其中 res 是上传数据，后台接口返回的参数，用于判断是否成功，成功的话，向父页面传参，并调用 mui.bac() 方法关闭页面。getRes 是监听的方法，父页面监听子页面的数据变化，需要用到这个监听方法，命名可以自取。 父页面： 12345678//监听子页面提交数据后，刷新页面window.addEventListener(&apos;getRes&apos;, function(event) &#123; //获得事件参数 var type = event.detail.type; if (type == 1) &#123; location.reload(); &#125;&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI父页面向子页面传参]]></title>
    <url>%2F2019%2F04%2F14%2FMUI%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%90%91%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[在以往有讲过 MUI 创建新页面 ，其中有提到 extras 传参。 我们可以在 a 标签中进行页面的跳转和传参，但是如果数据量较多的话，会影响代码的可读性，我建议还是写在 JS 中。 这里有一个很简单的例子,可以参考一下方法进行页面之间的传参。openUrl 的方法可以参考创建页面的那个方法。 父页面：12345//父页面传值$(&quot;#id&quot;).on(&quot;.child&quot;,&quot;tap&quot;,function()&#123; var id = $(this).attr(&quot;parameterID&quot;); openUrl(&apos;url&apos;,&apos;id&apos;,&#123;&apos;parameter&apos;:parameterID&#125;);&#125;); parameter是子页面接收参数的名字 子页面： 1234// 接收父页面传值var self = plus.webview.currentWebview();console.log(self.parameter);var parameterID = self.parameter; MUI 提供了很多父页面向子页面传参的方法，不过我个人用得比较多的是这一种方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI创建新页面]]></title>
    <url>%2F2019%2F04%2F13%2FMUI%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[在常规的前端开发中,我们经常使用a标签中的href属性来进行页面之间的跳转和传参. 但是这样会产生一个问题,a标签打开的页面返回时并不是返回到上一个页面,返回只是一个后退的操作. 如果对页面进行多次操作页面,当你想回到上一个页面时,就会来回的切换页面,严重影响体验. 在一个项目中,我们可以写一个公共的JS文件,创建新页面方法,代码如下. 12345678910111213141516171819202122//创建新页面function openUrl(url, id, params) &#123; if (typeof(params) == &apos;undefined&apos;) &#123; params = &#123;&#125;; &#125; if (mui.os.plus) &#123; mui.openWindow(&#123; id: id, //url:新页面的地址 url: url, //id:新页面的 WebView ID extras: params, //params:页面传参 styles: &#123; statusbar: &#123; //设置新页面状态栏背景颜色，以便达到沉浸式状态栏 background: &apos;#3EAD74&apos;, color: &apos;#FFFFFF&apos; &#125; &#125; &#125;) &#125; else &#123; window.location.href = url; &#125;&#125; 引用 js 文件后就可以,我们可以用a标签进行快速的使用. 1&lt;a href=&quot;javascript:openUrl(&apos;url&apos;,&apos;id&apos;,&#123;&#125;)&quot;&gt;打开新的 webview页面&lt;/a&gt; 我们可以很方便的用 a 标签进行传参，但是要注意的是，在动态生成的 DOM 结构里，用 a 标签来传参的话，页面跳转会失效。我的建议是用JS点击绑定事件进行页面的跳转和传参。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
</search>
