<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[预设图片比例]]></title>
    <url>%2F2019%2F04%2F21%2F%E9%A2%84%E8%AE%BE%E5%9B%BE%E7%89%87%E6%AF%94%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[在项目中，经常有用到图片，但是我们不能直接使用图片，防止图片大小不一致，而导致页面的布局错乱，但是又不能直接把图片的宽高写成固定的，不然图片会变形之类的。所以我们我们需要一个等比例的图片宽高，又不能使图片变形。我推荐采用以下这种方式。 1234// html &lt;div class=&quot;demoImg&quot;&gt; &lt;img src=&quot;http://images.leegeing.cn/hexoImg/demo.jpeg&quot;&gt; &lt;/div&gt; 12345678910111213141516// css.demoImg&#123; position: relative; width: 100%; height: 0; padding-top: 100%; overflow: hidden;&#125;.demoImg&gt;img&#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#125; 当 CSS 的宽度 width 和上内边距 padding-top 的都为 100%，代表的是 1:1 的图片比例。 当设置为宽高和上内边距的分别设置为 100%，和 75%的时候，代表的图片比例 4：3 的比例。 object-fit 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。 fill被替换的内容正好填充元素的内容框。整个对象将完全填充此框。如果对象的宽高比与内容框不相匹配，那么该对象将被拉伸以适应内容框。 contain被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“黑边”。 cover被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。 none被替换的内容将保持其原有的尺寸。 scale-down内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 浏览器的兼容性]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS字体溢出隐藏]]></title>
    <url>%2F2019%2F04%2F20%2FCSS%E5%AD%97%E4%BD%93%E6%BA%A2%E5%87%BA%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[单行字体溢出隐藏 123text-overflow:ellipsis;white-space: nowrap;overflow: hidden; 多行字体溢出隐藏 1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac-文件夹内快捷打开命令行]]></title>
    <url>%2F2019%2F04%2F19%2FMac-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E5%BF%AB%E6%8D%B7%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[macOS 的终端很好用，但是却不能像 Windows 那么便捷的文件夹内打开终端，只能手动 cd 定位到当前目录。 附上大佬的 GitHub 地址：OpenInTerminal 地址 打开下载地址，下载最新的文件 解压后得到一个 OpenInTerminal应用 和一个 iocn 文件夹，把OpenInTerminal应用拖进应用程序进行安装。 最后选择默认的终端就可以啦。 最后的效果就是如下图所示，在文件内点开就可以直接打开终端了。 重选选择默认终端，请在终端执行如下命令： 1defaults remove wang.jianing.OpenInTerminal OIT_TerminalBundleIdentifier]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI跨页面调用方法]]></title>
    <url>%2F2019%2F04%2F17%2FMUI%E8%B7%A8%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[因为公司项目用 MUI 用得比较多，有碰到如下需求： 在一个双 WebView 的上拉刷新下拉加载的页面中，A页面就是父页面，B页面就是列表页。A页面中还带有搜索框，搜索框中的值会被传到 B页面，进行数据请求。 1234//A页面function setTotal(parameters)&#123; ……&#125; 1234567891011//B页面var total = 需要传的参数;var evalstr = &apos;setTotal(\&apos;&apos; + total + &apos;\&apos;)&apos;;var wvs = plus.webview.all();for (var i = 0; i &lt; wvs.length; i++) &#123; console.log(&apos;webview&apos; + i + &apos;: &apos; + wvs[i].id); if(wvs[i].id==&quot;你的 WebView ID&quot;)&#123; wvs[i].evalJS(evalstr); &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo更换博客主题]]></title>
    <url>%2F2019%2F04%2F17%2FHexo%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Hexo 有很多主题可以选择，但是我试过好几种，还是喜欢 nexT 主题，集成了很多插件，用起来很方便。 安装 nexT 主题有多种方式，大同小异。我不过我使用的是 git clone 的方法。 首先克隆 nexT 的仓库到我们的博客中。 12cd 你的博客目录git clone https://github.com/iissnan/hexo-theme-next themes/next 编辑 博客配置文件 _config.yml 1theme: next NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 以防万一，我们先在本地预览博客是否成功更换了主题，启动本地服务预览一下。 1hexo s 如果成功了的话，那么就可以把博客重新部署到服务器上了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的DOS命令]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%B8%B8%E7%94%A8%E7%9A%84DOS-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[DOS命令：计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。 目前大家常用的操作系统有windows10,windows 7等，都是图形化的界面。在有这些系统之前的人们使用的操作系统是DOS系统。 macOS命令行的使用不全包括以下命令。 回看上一次执行的命令 1向上箭头&quot;↑&quot;和向下箭头&quot;↓&quot; 中断操作 1&quot;Ctrl+C&quot; 组合键或&quot;Break&quot;键 盘符: 直接进入某盘符 1如直接进入D盘，D： md 建立子目录 12md[盘符：][路径名]〈子目录名〉md c:\ fox （在当前驱动器c盘下创建子目录fox） cd 改变当前目录 12cd [/D] [drive:][path] (进入某一目录)cd ../ (返回上级目录) 查看当前目录下的文件和子目录列表 1dir 命令行清屏 1cls]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 简便替换空值]]></title>
    <url>%2F2019%2F04%2F17%2FJS%E7%AE%80%E4%BE%BF%E6%9B%BF%E6%8D%A2%E7%A9%BA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在与后台对接的时候，经常有时候会拿到一个空值 undefined，把 undefined 显示在页面上，对于普通用户来说，是不可行的。以下有一中简便的方便，快速替换 undefined。 这行代码的意思就是：如果值为false，那么就采用后面的，如果值为true，那么就采用前面的。1var myEntryStandard = ParentDelivery[i].EntryStandard||&quot;无&quot;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加全局搜索]]></title>
    <url>%2F2019%2F04%2F16%2FHexo%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[安装搜索插件hexo-generator-searchdb1npm install hexo-generator-searchdb --save 找到到博客配置文件 _config.yml，添加如下配置12345search: path: search.xml field: post format: html limit: 10000 Next 主题自带搜索设置，编辑主题配置文件：_config.yml找到文件中 Local search 的相关配置，设为 true 123# Local searchlocal_search: enable: true 重新部署 hexo123$ hexo clean$ hexo g$ hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS格式化时间戳]]></title>
    <url>%2F2019%2F04%2F16%2FJS%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E6%88%B3%2F</url>
    <content type="text"><![CDATA[在项目中经常会遇到后台接口返回来的时间戳，我们需要转换一下才能显示日常使用的时间格式。 1234567891011121314151617181920212223242526272829303132//转换时间格式function getNowFormatDate(setdate) &#123; var date = new Date(setdate); var seperator1 = &quot;-&quot;; var seperator2 = &quot;:&quot;; var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = &quot;0&quot; + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = &quot;0&quot; + strDate; &#125; var h = date.getHours(); var m = date.getMinutes(); var s = date.getSeconds(); if (h &gt;= 0 &amp;&amp; h &lt;= 9) &#123; h = &quot;0&quot; + h; &#125; if (m &gt;= 0 &amp;&amp; m &lt;= 9) &#123; m = &quot;0&quot; + m; &#125; if (s &gt;= 0 &amp;&amp; s &lt;= 9) &#123; s = &quot;0&quot; + s; &#125; var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate + &quot; &quot; + h + seperator2 + m; return currentdate;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI子页面向父页面传参]]></title>
    <url>%2F2019%2F04%2F15%2FMUI%E5%AD%90%E9%A1%B5%E9%9D%A2%E5%90%91%E7%88%B6%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[经常有这样的需求：子页面新增数据后完成后，跳转到父页面的列表界面。但是 MUI 采用的是页面跳转其实是打开新窗口，返回父页面并不会刷新父页面，只是把子页面关闭，父页面从始至终都在那里并没有刷新过。 思路：子页面提交数据后，向父页面传参，父页面监听子页面的参数，调用刷新方法，从而达到页面刷新，数据更新的目的。 子页面： 12345//向父页面传参mui.fire (plus.webview.currentWebview().opener(), &apos;getRes&apos;, &#123; &quot;type&quot;: 1&#125;);mui.back(); 其中 res 是上传数据，后台接口返回的参数，用于判断是否成功，成功的话，向父页面传参，并调用 mui.bac() 方法关闭页面。getRes 是监听的方法，父页面监听子页面的数据变化，需要用到这个监听方法，命名可以自取。 父页面： 12345678//监听子页面提交数据后，刷新页面window.addEventListener(&apos;getRes&apos;, function(event) &#123; //获得事件参数 var type = event.detail.type; if (type == 1) &#123; location.reload(); &#125;&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI父页面向子页面传参]]></title>
    <url>%2F2019%2F04%2F14%2FMUI%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%90%91%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[在以往有讲过 MUI 创建新页面 ，其中有提到 extras 传参。 我们可以在 a 标签中进行页面的跳转和传参，但是如果数据量较多的话，会影响代码的可读性，我建议还是写在 JS 中。 这里有一个很简单的例子,可以参考一下方法进行页面之间的传参。openUrl 的方法可以参考创建页面的那个方法。 父页面：12345//父页面传值$(&quot;#id&quot;).on(&quot;.child&quot;,&quot;tap&quot;,function()&#123; var id = $(this).attr(&quot;parameterID&quot;); openUrl(&apos;url&apos;,&apos;id&apos;,&#123;&apos;parameter&apos;:parameterID&#125;);&#125;); parameter是子页面接收参数的名字 子页面： 1234// 接收父页面传值var self = plus.webview.currentWebview();console.log(self.parameter);var parameterID = self.parameter; MUI 提供了很多父页面向子页面传参的方法，不过我个人用得比较多的是这一种方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI创建新页面]]></title>
    <url>%2F2019%2F04%2F13%2FMUI%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[在常规的前端开发中,我们经常使用a标签中的href属性来进行页面之间的跳转和传参. 但是这样会产生一个问题,a标签打开的页面返回时并不是返回到上一个页面,返回只是一个后退的操作. 如果对页面进行多次操作页面,当你想回到上一个页面时,就会来回的切换页面,严重影响体验. 在一个项目中,我们可以写一个公共的JS文件,创建新页面方法,代码如下. 12345678910111213141516171819202122//创建新页面function openUrl(url, id, params) &#123; if (typeof(params) == &apos;undefined&apos;) &#123; params = &#123;&#125;; &#125; if (mui.os.plus) &#123; mui.openWindow(&#123; id: id, //url:新页面的地址 url: url, //id:新页面的 WebView ID extras: params, //params:页面传参 styles: &#123; statusbar: &#123; //设置新页面状态栏背景颜色，以便达到沉浸式状态栏 background: &apos;#3EAD74&apos;, color: &apos;#FFFFFF&apos; &#125; &#125; &#125;) &#125; else &#123; window.location.href = url; &#125;&#125; 引用 js 文件后就可以,我们可以用a标签进行快速的使用. 1&lt;a href=&quot;javascript:openUrl(&apos;url&apos;,&apos;id&apos;,&#123;&#125;)&quot;&gt;打开新的 webview页面&lt;/a&gt; 我们可以很方便的用 a 标签进行传参，但是要注意的是，在动态生成的 DOM 结构里，用 a 标签来传参的话，页面跳转会失效。我的建议是用JS点击绑定事件进行页面的跳转和传参。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
</search>
